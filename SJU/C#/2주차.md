## <strong>데이터 타입</strong>
### <strong>기본 용어 : 표현식, 문장</strong>
- 표현식 : 값을 만들어내는 간단한 코드
```c#
273;
10 + 20 + 30 * 2;
Console.Write("C# Programming");
```
- 문장 (statement)
    - 프로그래밍에서 실행 가능한 최소 단위의 코드
    - ";" 기호는 문장의 끝을 의미

### <strong>기본 용어 : 키워드</strong>
- 키워드
    - C# 언어가 미리 선택하여 의무부여한 단어
    - 일반 키워드는 개발자가 변수로 선언 불가
        - bool, break, class, const, continue, do, else, event, goto, long, for, switch . . .
    - 문맥 키워드는 특정 위치에서만 키워드로 동작
        - add, alias, ascending, async, by, from, global . . .
    
### <strong>기본 용어 : 식별자</strong>
- 식별자 : 어떤 대상을 유일하게 구별 가능하게 하는 이름
    - 키워드 사용 불가
    - 특수문자는 "_"만 허옹
    - 숫자로 시작 불가
    - 공백 입력 불가

### <strong>C# 언어의 데이터 종류</strong>
- 기본 데이터 형식
    - 모든 데이터의 근간
    - 총 15가지 존재
    - 크게 숫자, 논리, 문자열, 오브젝트 형식으로 분류
- 복합 데이터 형식
    - 이미지나 소리 등의 데이터 표현
    - 구조체, 클래스, 배열 포함

### <strong>값 형식과 참조 형식</strong>
- 스택 메모리
    - 데이터를 탑을 쌓 듯이 밑부터 순차적으로 쌓고 꺼낼 때는 위에서부터 순차적으로 꺼낼 수 있는 구조
    - 예를 들어, (아래 박스 안에 코드의 경우)
        - 코드 블록이 시작하는 "{" 부터 변수 a, b, c가 순차적으로 쌓임
        - 코드 끝 "}"부터 c, b, a의 순으로 메모리가 비워짐
    - 스택은 코드 끝에서 메모리 자동제거
    - 값 형식의 데이터 스택 메모리 사용
- 힙 메모리
    - 메모리 제거를 위해 CLR의 가비지 컬렉터 이용
    - 개발자가 원할 때까지 데이터를 메모리에 유지 가능
        - 스택은 메모리 자동 비움
        - 나중에 데이터를 앞으로 사용 할 일이 없는 경우 CLR에 의해 제거
    - 참고 형식은 스택과 힙 메모리에 모두 사용
        - 힙 영역 : 데이터를 저장
        - 스택 영영 : 데이터가 저장된 힙 메모리 주소

### <strong>값 형식과 참조 형식 차이점</strong>
```c#
{
    int n1 = 5;
    int n2 = n1

    string txt1 = "C#";
    string txt2 = txt1;
}
```
<img width="810" alt="image" src="https://user-images.githubusercontent.com/99342700/232279705-4f48f037-d158-454f-93de-459f90fc805c.png">

### <strong>C# 데이터형 분류</strong>
<img width="806" alt="image" src="https://user-images.githubusercontent.com/99342700/232279816-c99be522-17c5-4e1e-bf30-a67107b034be.png">

### <strong>부호가 있는 정수와 없는 정수</strong>
- 부호 없는 정수 byte, ushort, uint, ulog . . .
- 부호는 간단하게 (+) 또는 (-)를 나타냄
- 2의 보수법으로 음수 표현
    1. 1을 수 부분에 입력
        - | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
    2. 1안 0으로 0은 1로 반전
        - | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |
    3. 반전된 비트에 1을 더함
        - | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
```c#
static void Main(string[] args)
{
    byte a = 255;           // 비트표현 : 1111 1111
    sbyte b = (sbyte)a;

    byte c = 128;           // 비트표현 범위 : 1000 0000
    sbyte d = (sbyte)c;     // sbyte 범위    : -128 ~ 127

    Console.WriteLine(a);
    Console.WriteLine(b);
    Console.WriteLine(c);
    Console.WriteLine(d);
    /*
    출력 결과
    255
    -1
    128
    -128
    */
}
```

### <strong>object</strong>
- 어떤 데이터이든지 다룰 수 있는 형식
    - 모든 데이터 형식이 object 형식으로 부터 상속 받음
<img width="830" alt="image" src="https://user-images.githubusercontent.com/99342700/232280571-725ea227-ddce-4904-bf10-9c476d50117e.png">

```c#
static void Main(string[] args)
{
    object a = 123;
    object b = 3.1415_9265m;
    object a = true;
    object a = "안녕하세요";

    Console.WriteLine(a);
    Console.WriteLine(b);
    Console.WriteLine(c);
    Console.WriteLine(d);
    /*
    출력 결과
    123
    3.14159265
    True
    안녕하세요
    */
}
```

### <strong>박싱과 언박싱</strong>
- 박싱 (Boxing) -> 참조식
    - 값 형식의 데이터를 힙에 할당 방법
    ```c#
    object a = 20;
    ```
- 언박싱 (Unboxing) -> 참조식의 값을 값형식으로 다시 저장
    - 박식된 값을 거내 값 형식 변수에 저장하는 과정
    ```c#
    object a = 20;
    object b = (int)a;
    ```

### <strong>데이터형 변환</strong>
- 암시적 변환
    - 범위가 작은 데이터 타입에서 범위가 큰 타입으로 변환
    - 부가적인 코드를 지정하지 않고 형변환
    ```c#
    btye b = 250;    // btye 범위 0 ~ 255
    short s = b;    // short 범위 -32,768 ~ 32,767
    ```
- 명시적 변환
    - 개발자가 의도한 형변환임을 컴파일러에 알리는 변환
    - 예 : 개발자가 의도하여 char형 변수에 'A'의 숫자 값 65 입력
    ```c#
    ushort u = 65;          // 'A'의 숫자 값은 65
    char c = (char)u;       // char 형에 숫자를 그대로 입력하면 에러 발생
    Console.WriteLine(c);   // 출력 결과 : A
    ```

### <strong>Parse()메소드와 ToString()메소드</strong>
- "Parse(.)" 메소드
    - 숫자로 변환할 문자열을 숫자로 변환
    - 모든 정수, 부동 소수점 형식에서 지원되는 메소드
    ```c#
    string a = "123456";
    int b = int.Parse(a);
    Console.Write(b);
    /*출력 결과 : 123456*/
    ```
- "ToString()" 메소드
    - 숫자로부터 문자열 출력
    - object로부터 상속 받은 ToString() 메소드를 재정의
    ```c#
    int a = 123;
    string b = a.ToString();
    Console.Write(b);
    /*출력 결과 : 123*/
    ```
### <strong>상수와 열거 형식</strong>
- 상수와 열거 형식은 안에 담긴 데이터를 변경 불가
- 상수의 선언은 변수의 선언과 유사
```c#
const int a = 3; // 선언 형식
a = 4;           // 상수 값 변경 시 컴파일 에러 발생
```
- 열거 형식은 여러 개의 상수를 선언
    - 선언 형식 
```c#
enum a {YES, NO, CANCEL, CONFIRM, OK}

static void Main(string[] args)
{
    Console.WriteLine((int)a.YES);
    Console.WriteLine((int)a.NO);
    Console.WriteLine((int)a.CANCEL);
    Console.WriteLine((int)a.CONFIRM);
    Console.WriteLine((int)a.OK);
}
enum a {YES, NO, CANCEL = 50, CONFIRM, OK}

static void Main(string[] args)
{
    Console.WriteLine((int)a.YES);
    Console.WriteLine((int)a.NO);
    Console.WriteLine((int)a.CANCEL);
    Console.WriteLine((int)a.CONFIRM);
    Console.WriteLine((int)a.OK);
}
    /*
    출력 결과_1
    0
    1
    2
    3
    4
    */

    /*
    출력 결과_2
    0
    1
    50
    51
    52
    */
```
### <strong>Nullable형식</strong>
- 값 형식의 변수가 "비어 상태가" 될 수 있는 형식
- 원래 데이터 형에 ? 를 붙여서 선언
- 선언 형식 : int ? a = null;
- Nulllable형식 변수에 값 할당 없이 사용하면 컴파일 에러 발생
    - null 또는 해당 데이터 형 범위 내의 값 할당 가능
- HasValue와 Value 속성을 가짐
    - HasValue : 해당 변수가 값을 가지고 있는지 확인
    - Value : 변수에 담겨 있는 값
```c#
int ? a = null;
Console.WriteLine(a.HasValue);
Console.WriteLine(a != null);
a = 3;
Console.WriteLine(a != null);
Console.WriteLine(a.Value);
/*
출력 결과
False
False
True
3
*/
```

### <strong>var 키워드</strong>
- 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식 지정
    - 변수 선언과 동시에 초기화 필요
    - 초기화 데이터에 따라 해당 변수의 형식 지정
    - 지역 변수로만 사용할 수 있음
- var키워드와 object형과의 차이점
    - 예를 들어 "var a = 3;"과 objext a = 3"을 비교하면,
    - object 형식의 경우 CLR이 3을 박싱해서 힙에 넣고 a가 힙을 가리키도록 설정
    - var키워드의 경우 컴파일 시점에서 a의 데이터형을 int로 바꿔 컴파일

