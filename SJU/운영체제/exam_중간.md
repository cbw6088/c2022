## <strong>CH.01</strong>
### <strong>Common Function of Interrupts</strong>
<br>보통 컴퓨터는 여러 작업을 동시에 처리하는데, 만약 CPU가 인터럽트 신호를 받으면 앞서 말했듯이 하던 일을
<br>잠시 멈추고 메모리의 어떤 고정된 위치를 찾는다. 이 위치는 인터럽트 벡터에 저장되어 있다.
<br>인터럽트 벡터는 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간으로, 파일 읽기/쓰기와 같은 중요한 동작들이 하드코딩 되어있다.
<br>이렇게 인터럽트를 처리하고 나면 CPU는 다시 원래 작업으로 돌아온다. 이 과정은 사용자가 눈치채지 못할 정도로 빠르거나 혹은 매우 느리다.

- 트랙(Trap) or 예외(Exception)
    - 오류(0으로 나누거나 유효하지 않은 메모리 접근)
    - 사용자 프로그램의 운영체제 서비스 요청에 의해서 유발되는 SW에 의해 생성

### <strong>Interrupt Handling</strong>
<br>현대 운영체제들은 대부분 인터럽트 주도적(Interrupt driven)이다. 인터럽트가 발생하기 전까지 CPU는 대기상태에 머문다.
<br>반면 폴링(Polling)의 경우 주기적으로 이벤트를 감시해 처리 루틴을 실행한다. 이렇게 하면 컴퓨터 자원을 낭비하게 되기 때문에 Interrupt driven으로 설계한다.

- 폴링(Polling) : 한 개씩 물어보는 방법 (좁은 범위)
- 인터럽트 벡터 방식 : ISR의 수행을 통해 조치를 취함 (넓은 방식)
- 처리 과정
    1. 인터럽트 요청 받음
    2. 현재 수행중인 명령 완료
    3. 현재 수행중인 프로그램 일시 중단
    4. 수행중인 프로그램 상태를 안전한 장소에 저장
    5. 인터럽트 처리 루틴을 수행 (인터럽트 원인 찾기 -> 인터럽트  핸들러 수행)
    6. 다시 인터럽트 처리 기능을 이용하여 미리 보존한 프로그램 상태 복구
    7. 인터럽트 당한 프로그램을 중단된 곳에서 부터 다시 계속 실행할 수 있도록 조치

### <strong>Interrupt Timeline</strong>
<img width="532" alt="image" src="https://user-images.githubusercontent.com/99342700/232965481-b8059e48-75fd-45f6-b1bc-04d5b796aba1.png">

### <strong>I/O Structure</strong>
<br>기억장치는 여러 입출력장치(I/O devices) 중 하나일 뿐이다. 컴퓨터는 다양한 입출력 장치를 가지고 있으며, 입출력 컨트롤러는 각각 다른 장치를 담당한다.
<br>컴퓨터는 이 컨트롤러 덕분에 다양한 장치를 사용할 수 있다. 또한 운영체제는 각 장치 컨트롤러를 제어하기 위한 장치 드라이버를 가지고 있다.
<br>
<br>입출력 명령을 수행하기 위해 장치 드라이버는 장치 컨트롤러의 레지스터를 로드한다. 장치 컨트롤러는 레지스터에서 "키보드로부터 문자 읽어오기"와 같은
<br>동작을 읽고, 장치에서 로컬 버퍼로 데이터를 전송하기 시작한다. 데이터의 전송이 끝나면 장치 컨트롤러는 장치 드라이버에게 인터럽트를 보내 동작이 끝났음을 알리고
<br>장치 드라이버는 통제원을 운영체제에게 돌려준다. 이때 입력 받은 데이터나 상태 정보를 넘겨주기도 한다.
<br>
<br>사용자 프로그램은 커널과 사용자 프로그램을 매개하는 인터페이스인 시스템콜을 통해 입출력을 요청할 수 있다.

### <strong>Stroage Structure</strong>
<br>커널은 실행기를 통해 프로그램을 실행시킨다. 실행기는 기억장치(Storege)에서 exe파일을 가져오고, 커널이 이것을 메모리에 할당해 실행시킨다.
<br>이처럼 모든 프로그램은 메인 메모리에 로드되어 실행되며, 메인 메모리는 보통 RAM(Rand-Access Memory) 이라고 부른다.
<br>하지만 RAM은 모든 프로그램을 담기엔 너무 작고 비싸다. 또한 전원이 나가면 저장된 데이터가 모두 사라지는 휘발성(Volatile)장치이다.
<br>그래서 비휘발성(Non-Volatile) 장치인 보조기억장치(Secondary Storage)가 필요하다.
<br>보조기억장치는 자기테이프(Magnetic tapes), 광학디스크(Optical disk), 자기디스크(Magnetic disk), SSD(Soli=State Disk)가 있다.
<br>반면 메인 메모리, 캐시(Chche), 레지스터는 휘발성 기억장치다. 보저기억장치는 용량이 크고 저렴한 반면, 캐시나 레지스터는 용량이 작고 비싸다.
<br>
<br>요즘 컴퓨터에는 최대 절전 모드가 있는데, 이 방식이 꽤 재미있다. 컴퓨터가 절전모드에 들어가면 메모리의 모든 데이터를 덤프해서 보조기억장치에 담아두고,
<br>다시 절전모드에 빠져나오면 덤프해둔 데이터를 불러와 그대로 작업을 수행한다. 이를 Hibernate라고 한다.
<br>

### <strong>Storage Hierarchy</strong>
<br>저장 용량 및 엑세스 시간에 따른 계층 구조
<img width="752" alt="image" src="https://user-images.githubusercontent.com/99342700/232968450-20834b6a-20e5-4ae4-8518-8bd7991c9361.png">

- 메모리가 작고 빠를수록 CPU에 가깝다.
- 휘발성 저장장치는 장치의 전원이 제거될 때 내용을 잃어버리므로 안전하게 보관하기 위해 데이터를 비휘발성 저장장치에 기록해야다.
- 캐싱(Chaching)
    - 정보를 faster storage에 저장시키는 개념으로 자주 쓰는 정보들은 cache에 저장하는 것이 효율적이다.
    - CPU에 있는 캐시로 처리 -> 캐시보다 메인메모리가 크기 때문에 90% 정도만 캐시에 있고, 남은 10%는 메인메모리에 있어서 한 번씩 메인메모리로 이동한다.
    - 캐시는 두 구성요소 간에 액세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다.
- 디바이스 드라이버(Device Driver)
    - I/O driver와 통신을 가능하게 해주는 소프트웨어
    - 디바이스 드라이버의 종류 : 키보드, 마우스, 디스크 드라이버 등등 . . .

### <strong>How a Modern Computer Works</strong>
<img width="715" alt="image" src="https://user-images.githubusercontent.com/99342700/232975017-33adbc1a-526d-4b9d-b9e0-eae75858b256.png">

### <strong>DMA(Direct Memory Access)</strong>
- CPU를 대신하여 I/O장치와 Memory 사이의 데이터전송을 담당하는 장치를 지칭
- CPU개입 없이 주변장치(입출력장치)와 주기억장치와의 데이터 전송이 이루어지는 방법을 통칭
- CPU와 주기억장치만이 시스템 버스에 접근할 수 있고 입출력장치는 DMA와 같은 입출력 제어기에 의해 시스템 버스에 접근할 수 있다.
<img width="591" alt="image" src="https://user-images.githubusercontent.com/99342700/232975980-1cab5cd7-ea54-401e-bd27-d19ae1fb80fd.png">

- DMA의 특징
    - CPU의 개입 없이 주변장치와 주기억장치와의 데이터 직접 전송
    - 프로그램 수행 중 입출력을 위한 인터럽트의 발생 횟수를 최소화하여 컴퓨터 시스템의 효율을 높임
    - CPU는 DMA와 상태정보 및 제어정보만을 주고 받음
    - 속도가 빠른 디스크, 테이프 등에 사용됨
    - DMA는 기억장치 접근을 위해 CPU의 시스템 버스 사용권을 일시적으로 뺏는 사이클 스틸링을 수행한다. 시스템 버스에 대해 CPU보다 DMA의 우선순위가 높다.
    - DMA제어기와 CPU가 시스템 버스를 공유한다.

<img width="594" alt="image" src="https://user-images.githubusercontent.com/99342700/232977188-901d6c3e-2ea9-4408-874b-fad2ed2f49af.png">

- 실제 CPU가 Control하는건 DMAC(DMA Controller)를 Control해주는 과정을 의미한다.

## <strong>CH.02</strong>
### <strong>System Call Implementation</strong>
<br>시스템 콜은 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.
<br>
<br>사용자 프로그램이 디스크 파일을 접근하거나 화면에 결과를 출력하는 등의 작업이 필요한 경우, 즉 사용자 프로그램 특권 명령의 수행을 필요로 하는 경우,
<br>운영체제에게 특권 명령의 대행을 요청하는 것이 시스템 콜이다.

- 통상적으로 시스템 콜은 여러 종류의 기능으로 나누어진다.
- 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템  콜 테이블을 유지한다.
- 운영체제는 자신의 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는루틴을 수행한다.
- 작업이 완료되면 CPU에게 인터럽트를 발생시켜 수행이 완료 되었음을알린다.
- open()호출
    - open()이라는 시스템 콜의 인덱스가 가리키는 곳에 이에 대한 처리 과정이 저장되어 있다.
<img width="635" alt="image" src="https://user-images.githubusercontent.com/99342700/232978383-bfc10865-663a-4f27-b0c6-023849612fb1.png">

- 경우에 따라 시스템 콜이 발생했을 때, 추가적인 정보가 필요할 수도 있는데 그러한 정보가 담긴 매개변수들을 OS에 어떻게 전달할까?
    - 매개변수를 CPU레지스터에 전달한다.
        - 전달해야 하는 매개변수 보다 레지스터의 수가 작을 수 있다.
    - 매개변수를 메모리에 저장해 해당 메모리의 주소를 레지스터에 전달 할 수 있다.
    - 매개변수는 프로그램에 의해 스택(stack)에 전달(push)될 수도 있다.
        - 2, 3번의 경우 매개변수의 개수나 길이의 제한이 없기 때문에 선호되는 방식이다.
        <img width="414" alt="image" src="https://user-images.githubusercontent.com/99342700/232979518-4b5a4e84-77a4-4e58-a4f0-f9f1503d82a0.png">

### <strong>UNIX(Non Simple Structure)</strong>
<img width="552" alt="image" src="https://user-images.githubusercontent.com/99342700/232980473-b1511301-90ea-4fd7-ae53-e37c3a22a950.png">
<br>위의 구조는 처음의 유닉스 구조로 시스템 호출 인터페이스와 하드웨어 위의 공간이 모두 커널로 구성되어 있다. 그래서 시스템 호출을 통해서
<br>파일 시스템, CPU 스케줄링, 메모리 관리 등의 기능을 제공한다.

- 초기의 70, 80s의 UNIX는 두 개로 분리 가능한 구조였다.
    - Systems programs과 The kernel
- 모든 것이 system call interface(이를 통해 kernel로 접근) 아래로 구성되었고, 물리적인 하드웨어 위로 구성되었다.
- CPU scheduling, memory 관리, file system과 같은 OS 시스템 기능을 하나의 level에서 많이 제공했다.
    - 단일 정적 이진트리에 한꺼번에 kernel, OS의 모든 핵심 기능을 구현했다. (monolithic kernel structure)
- kernel내의 통신속도는 빨랐으나, 구현하기 어렵고 유지보수와 확장이 어려웠다.
- 하나의 입구를 통해서 접근해야 했다. 때문에 system call interface의 overhead가 거의 없었다.

### <strong>Layered Approach</strong>
- Simple Structure 다음으로 나온 방법이 Layer approach 방식이다. 이 계층적 접근 방식은 OS를 여러 개의 계층으로 분할하여 각각의 계층은 독립적인 서비스와 기능을 사용하도록 설계하는 것이다.
<img width="361" alt="image" src="https://user-images.githubusercontent.com/99342700/232981801-8820b233-9034-43a7-8a5f-60ff2fce74a6.png">

- 장점 : 설계와 구현이 단순하여 각 계층별로 독립적이기 때문에 구축과 디버깅이 단순해진다. 또한, 각 계층에서 문제가 생겼을 경우 문제가 생긴 계층만 해결하면 된다.
- 단점 : OS를 계층별로 분류할 수 있는 기준이 없기 때문에 계층을 나누기에 애매하다. 또한 계층별로 자원관리가 어려우며 시간도 오래 걸리고 인터페이스 설계가 어렵다.

## <strong>CH.03</strong>
### <strong>Process Concept</strong>
- 프로세스란 실행중인 프로그램을 말한다.
- 프로세스는 현대 컴퓨팅 시스템에서 작업의 단위가 된다.
- 프로세스 개념이 생긴 이유
    - 초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용하였고, 이 프로그램은 시스템을 완전히 제어하고 시스템의 모든 자원에 접근할 수 있었다.
    - 하지만, 오늘날의 컴퓨터 시스템은 메모리에 다수의 프로그램을 적재시켜 병행할 수 있게 되었고,
    - 때문에 다양한 프로그램을 보다 견고하게 제어하고 구획화해야 했으므로 프로세스의 개념이 생기게 되었다.

### <strong>Process in Memory</strong>
<img width="750" alt="image" src="https://user-images.githubusercontent.com/99342700/232988910-52a557c9-fdcc-4516-8de5-b2612632f282.png">

- text section : 실행 코드
- data section : 전역 변수
- heap section : 프로그램 실행 중 동적으로 할당되는 메모리
- stack section :  함수 호출 시, 임시 데이터 저장 장소 (함수 매개변수, 복귀 주소 및 지역 주소)
- text과 data의 크기는 고정되어 있고, heap, stack는 프로그램 실행 중 동적으로 늘어나거나 줄어들 수 있다.
<br>

- 이유는 text, data는 실행 코드와 전역변수 이므로, 프로그램 실행 시 그 것이 유지되며 더 늘어나거나 줄어들지 않는다.
- 반면, stack은 함수가 호출되면 임시 데이터를 담은 활성화 레코드는 stack에 pop되고, 또는 함수 제어에서 돌아오면 stack에 pop되기 때문이고
- heap은 메모리가 동적으로 할당, 반환 될 때 마다 동적으로 커지기 때문이다.
- 이렇게 두 영역은 동적으로 크기가 변하기 때문에, 운영체제는 두 영역이 겹치지 않도록 해야한다.
<br>

### <strong>Program and Process</strong>
- 프로그램과 프로세스는 다르다.
    - 프로그램은 수동적 존재(Passive entity), 프로세스는 능동적 존재(Active entity)
- 실행 파일이 메모리에 적재되었을 때, 프로그램이 프로레스가 되는 것이다.
- 동일한 프로그램을 실행한다고 해서(예를 들어, 복사본) 같은 프로세스라고 할 수 없다.
- 그 둘의 텍스트 영역은 같을지라도, 데이터 / 힙 / 스택 영역은 다를 수 있다.
- 프로세스가 실행되는 과정에서 다른 많은 프로세스를 생성하는 일은 흔하며, 이 프로세스가 다른 프로세스를 실행시키는 환경이 될 수 있다.
- 그 좋은 예가 Java와 JVM이다.
    - JVM은 Java코드를 해석하고 그 코드를 대신하여 원 기계어를 이용해 행동을 취하는 프로세스로서 프로그램을 실행한다.

### <strong>Diagram of Process State</strong>
<img width="650" alt="image" src="https://user-images.githubusercontent.com/99342700/232986673-24b19068-313b-4a96-a960-ed6f1c56be14.png">

### <stron>Process of State</strong>
- new : 프로세스 생성
- running : 프로세스가 실행되는 상태
- waiting : 프로세스가 어떠한 이벤트를 기다리는 상태
- ready : 프로세스가 실행이 가능한 상태
- terminated : 프로세스 종료
- 어느 한 순간 하나의 프로세서 코어에서는 오직 하나의 프로세스만이 실행될 수 있다. 하지만, 다수의 프로세스들이 ready, waiting상태에 있을 수 있다.
### <strong>Process Control Block (PCB)</strong>
- 운영체제에서 각 프로세스는 PCB에 의해 표현된다.
- PCB는 특정 프로세스와 연관된 다음과 같은 정보들을 수록한다.
    - 프로세스 상태 : 위에서 설명한 new, running, waiting . . .
    - 프로그램 카운터 : 해당 프로세스가 다음 실행 할 명령어의 주소를 가리킨다.
    - CPU 레지스터들 : accumulator, index register 등등 . . .
        - 이 레지스터들과 프로그램 카운터는 프로세스가 다시 스케줄 될 때, 올바르게 실행되기 위해 인터럽트 발생 시 저장되어야 한다.
    - CPU-스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터, 다른 스케줄 매개변수
    - 메모리 관리 정보 : base register, limit register의 값과 페이지 테이블 또는 세그먼트 테이블 등
    - 회계(accounting) 정보 : CPU 사용 시간, 경과된 실시간, 시간 제한, 계정 번호, 프로세스 번호 등
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들, 열린 파일 목록
- PCB는 약간의 accounting data와 프로세스를 시작, 다시 시작할 때 필요한 데이터들의 저장소 역할을 한다.

### <strong>CPU Switch From Process to Process</strong>
<img width="539" alt="image" src="https://user-images.githubusercontent.com/99342700/232990224-794b1ee0-3ff4-4fdf-a6b4-6adc770062ea.png">

### <strong>Threads</strong>
- 스레드: 하나의 프로세스 내에서 실행되는 여러 흐름의 단위
- 각 스레드는 스택만 할당받고 코드, 데이터, 힙 등은 프로세스 내에서 공유한다.
- OS의 스케쥴러는 스레드를 최소 단위로 작업
- 각각의 스레드는 프로세스와 달리 비정상적으로 종료되면 다른 스레드들도 종료된다.
- 위 프로세스 모델은 프로세스가 단일 스레드(single thread)를 실행하는 프로그램임을 가정하고 논의하였다.
    - 예를 들어, 사용자가 문자를 입력하면서 동시에 철자 검사기를 실행할 수 없다. (한 프로그램에 두 가지 기능이 있다.)
- 하지만, 현대 운영체제는 한 프로세스가 다수의 실행 스레드를 가질 수 있다.
- 이런 특징은 여러 스레드를 병렬로 실행시킬 수 있는 멀티 코어 시스템에서 특히 이득을 얻을 수 있다.
- 스레드를 지원하는 시스템에서 PCB는 위 학목에 각 스레드에 관한 정보를 포함하도록 확장되어야 한다.

## <strong>예상 문제</strong>
1. 운영체제가 하드웨어 인터럽트를 처리하는 과정
    1. 인터럽트 요청 발생
    2. 프로그램 수행 중단
    3. PC에 기억되어 있는 주소를 안전한 곳에 기억시켜서 보존
    4. 인터럽트 전처리 실행
    5. 인터럽트 처리 루틴 수행
    6. 보존시킨 PC의 값을 PC에, 보존시킨 프로그램의 상태를 환원시킨 프로그램의 수행을 중단되었던 곳에서부터 계속하여 수행되도록 함
    
    