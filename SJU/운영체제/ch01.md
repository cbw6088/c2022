## <strong>운영체제란?</strong>
- 사용자와 하드웨어 사이에 중개자 역할

### <strong>운영체제의 역할</strong>
- 사용자의 프로그램을 실행하고 문제를 더 쉽게 해결
- 사용자에게 편의 제공
- 컴퓨터 하드웨어의 효율적인 사용

## <strong>컴퓨터 시스템 구조</strong>
### <strong>주어진 작업을 실행하기 위해 네 개의 구성 요소 필요</strong>
- 하드웨어 (Hardware)
    - 기본적인 컴퓨팅 자원을 제공
    - CPU, Memory, I/O devices, Disk
    - 리소스의 정의 : 사전적 의미로 자원이며, 프로그램이 구동되면서 필요한 영역, 메모리, 스케줄링 등을 의미
    - CPU -> Memory -> Disk(파일 관리) / I/O Devices(입출력 관리)
- 운영체제 (Operating System)
    - 다양한 에플리케이션 및 사용자 간의 하드웨어 사용 제어 및 조정
    - 제어(Controls) : 컴퓨터에서 보유하고 있는 자원의 효율적인 관리를 위한 프로그램
    - 조정(Coordinates) : 사용자의 편의를 제공하는 프로그램
- 어플리케이션 프로그램
    - 시스템 리소스가 사용자의 컴퓨팅 문제를 해결하는 데 사용되는 방법을 정의
    - 사용자가 제시한 계산 문제들을 해결하기 위한 방법을 제시하는 것으로
        - 워드프로세서 / 컴파일러 / 웹 브라우저 / 데이터베이스 시스템 / 비디오 게임 등등이 있음
- 유저
    - 사람(사용자) / 기계 / 그 외 컴퓨터
<img width="429" alt="image" src="https://user-images.githubusercontent.com/99342700/224535072-8a8e75c7-3985-46f9-8f9c-7000e052bd8a.png">

## <strong>운영체제는 무엇을 하는가?</strong>
- 관점에 따라 다름
- 유저들은 자원 활용률을 신경쓰지 않고 우수한 성능과 편의성을 원해함
    - 자원 활용률을 신경쓰지 않음
    - 그러나 메인프레임 또는 미니컴퓨터와 같은 공유 컴퓨터는 모든 사용자를 행복하게 해줘야 함
- 워크스테이션과 같은 전용 시스템의 사용자는 전용 리소스를 가지고 있지만 서버의 공유 리소스를 자주 사용합니다
- 휴대용 컴퓨터는 사용성과 배터리 수명에 최적화된 리소스가 부족
- 일부 컴퓨터는 장치나 자동차에 내장된 컴퓨터와 같이 사용자 인터페이스가 거의 없거나 전혀 없음

## <strong>운영체제의 정의</strong>
- OS는 자원을 할당한다
    - 모든 자원을 관리함
    - 효율적이고 공정한 리소스 사용에 대한 상충되는 요청 사이에 결정
- OS는 제어 프로그램이다
    - 오류나 부적절한 사용을 방지하기 위한 제어
- 보편적으로 정의가 허가된 적 없다
- 운영체제를 요청 할 때 제공하는 모든것은 적절한 근사치다 -> 하지만 각각 천차만별
- 항상 작동하는 하나의 프로그램인 커널이다
    - 커널  
        - 운영체제 중 항상 메모리에 올라가 있는 핵심부분
        - 하드웨어와 응용프로그램 사이에서 인터페이스를 제공하는 역할
        - 컴퓨터 자원들을 관리하는 역할
        - 다만, 사용자와의 상호작용이 안되므로 Shell등을 사용해야 함
- 시스템 프로그램
    - 운영체제를 구성하는 프로그램과 파일 시스템
    - 가장 기본적인 수준에서 실행하므로 저수준 소프트웨어 라고 불리기도 함
    - 응용프로그램 소프트웨어를 실행할 수 있는 환경을 제공
    - 컴퓨터 및 기기에 설치된 응용프로그램 제어
- 어플리케이션 프로그램
    - 컴퓨터의 기능을 활용하는 컴퓨터프로그램의 하위 클래스
    - 시스템 프로그램 없이 실행 불가

## <strong>컴퓨터 시작</strong>
- <strong>부트스트랩</strong> 프로그램이 전원을 켜거나 재부팅할 때 로드됨
- 부트스트랩의 예 : 컴퓨터를 키면 자동으로 시작되는 프로그램
- 일반적으로 ROM 또는 EPROM에 저장되며, 일반적으로 firmware라고 함
- 시스템의 모든 측면을 초기화
- 운영체제 커널을 로드하고 실행

## <strong>컴퓨터 시스템 조직</strong>
- 컴퓨터 시스템 작동
    - 공유 메모리에 대한 액세스를 제공하는 하나 이상의 CPU, 하드웨어가 공통 버스를 통해 연결됨
    - 메모리 주기를 두고 경쟁하는 CPU 및 디바이스의 동시 실행
    - CPU는 해당 장치로 바로 가기 때문에 빠름
    - 그 외에는 버퍼를 거쳐 장치로 가기 때문에 비교적 느림
<img width="478" alt="image" src="https://user-images.githubusercontent.com/99342700/224535865-83fb4013-08ef-4b28-9987-f1d6ed9131ab.png">

## <strong>컴퓨터 시스템 작동</strong>
- I/O장치와 CPU는 동시에 실행된다.
- 각각의 장치 컨트롤러는 특정 장치의 유형을 담당한다.
- 각각의 장치 컨트롤러는 로컬 버퍼를 갖는다.
- CPU는 데이터를 main메모리에서 로컬 버퍼로 이동시킨다.
- I/O는 장치부터 컨트롤러의 로컬 버퍼까지이다.
- 장치컨트롤러는 CPU에 인터럽트를 발생시켜 작업이 완료되었음을 알린다.
- O/S와 Operating이 같이 구동됨으로 서로가 타협이 필요하다. -> 서로간에 소통 할 방법이 필요하다. (2개의 인터럽트)

## <strong>인터럽트의 실행 기능</strong>
- 인터럽트는 일반적으로 모든 서비스 루틴의 주소를 포함하는 인터럽트 벡터를 통해 제어권을 인터럽트 서비스 루틴으로 이전한다
    - interrupt : 운영 체제에서 컴퓨터에 예기치 않은 일이 발생하더라도 작동이 중단되지 않고 계속적으로 업무 처리를 할 수 있도록 해 주는 기능.
    - interrupt vecotr : 인터럽트 벡터는 인터럽트가 발생했을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간이다.
- 인터럽트 아키텍처는 인터럽트된 명령의 주소를 저장해야 한다.
    - 모든 정보를 O/S에 저장 후 현재 인터럽트가 무엇인지 물어보고 수행
- 트랩 또는 예외는 오류 또는 사용자 요청으로 인해 발생하는 소프트웨어 생성 인터럽트입니다
- 운영 체제가 인터럽트로 구동됨
    - 드리븐의 예 : 골-드리븐 , 데이터드리븐
    - 인터럽트 드리븐 : 필요할 때 만 O/S가 도와줌
    - 타임 인터럽트 : 수 많은 프로그램이 동시에 수행되는것 처럼 작동

## <strong>인터럽트 처리</strong>
- 운영체제는 레지스터와 프로그램 카운터를 저장함으로써 CPU의 상태를 유지한다. -> O/S가 쓰는 메모리에 저장
- 인터럽트가 발생하는 유형을 결정
    - Polling : 적은 범위
    - Vectored interrupt system : 많은 범위
- 각 유형의 인터럽트를 결정하는 코드의 부분을 결정
    - 인터럽트 : 질문함
    - 폴링 : 아무도 질문을 안해서 직접 질문이 있는지 물어봄
    - 상태 : 대기 상태 / 실행 상태 / 준비 상태(ex : 볼펜이 다 닳아서 사고오는 시간)

## <strong>I/O 구조</strong>
- O/S가 없으면 프로그램 수행을 어떻게 하는지 사람이 모두 직접 해야한다.
    - ex) 크기, 이름, 종류 등등 직접 정해서 프로그램 처리해주는 사람에게 줘야함
- I/O가 시작된 이후에는 I/O가 완료시에만 컨트롤이 사용자 프로그램에 돌아간다.
    - 대기명령 : 다음 인터럽트가 발생할 때 까지 CPU를 대기 상태로 둡니다.
    - 대기루프 : 메모리 엑세스의 경쟁
    - 한 번에 최대 하나의 I/O요청이 미결 상태이며, 동시 I/O처리는 없음
- I/O가 시작된 이후에는 I/O완료시 대기 없이 컨트롤이 유저 프로그램에 반환 된다.
    - 현재 처리중인 프로그램이 대기할 때 까지 기다리지 않고 다음 작업으로 넘어간 후 프로그램 대기가 끝나면 다시 가서 처리 (인터럽트)
    - System call - 사용자가 I/O가 완료되는 것을 기다릴 수 있도록 OS에 요청
    - Device-status table에는 각각의 I/O 디바이스의 유형, 주소, 상태를 나타내는 항목이 포함됨.
    - 장치 상태를 확인하고 인터럽트를 포함하도록 테이블을 수정하기 위한 I/O장치 테이블에 대한 O/S인덱스
    - 예시 코드에서 I/O가 아닌 것 : a = b, c = a + b, if(), while() . . .

## <strong>스토리지의 구조</strong>
- Main memory - CPU가 직접 접근 할 수 있는 대용량 스토리지
    - 휘발성 메모리
    - Random Access Memory(임의 접근 메모리 : 램)
        - 항상 동일한 시간이 걸림
        - 컴퓨터의 메인 메모리
        - 전원이 꺼지면 가지고 있던 데이터가 사라짐 (휘발성)
        - O/S 및 사용중인 데이터가 디바이스의 프로세서를 통해 신속하게 도달하게 도와주는 하드웨어
    - Direct Memory Access(직접 메모리 접근)
        - RAM에 비해 느림
        - CPU가 개입 없이 메모리를 읽거나 메모리에 쓸 수 있는 I/O 모듈 권한을 부여 받은 장치라고 봐도 무방
        - 메인 메모리와 I/O장치간의 교환을 제어
        - CPU는 전송의 시작과 끝에만 관여하고, 전체 블록이 전송된 후에만 중단
    - Secondary storage(보조 저장 공간) : 대용량 비휘발성 스토리지 용량을 제공하는 메인 메모리 확장
    - Magnetic disks : 단단한 금속이나 유리 접시를 덥는 자기 컴퓨터 부품
        - 디스크의 표면이 논리적인  트랙으로 나뉘고, 섹터로 세분화 됨
        - 디스크 컨트롤러는 장치와 컴퓨터 사이에 논리적인 상호작용을 결정함
    - Solid-state disks : 마그네틱 디스크보다 빠르고, 비휘발성
        - 다양한 기술
        - 더 대중화 됨

## <strong>저장 계층</strong>
- 저장 시스템은 계층에 조직화 됨
    - 속도, 비용, 휘발성
- Caching : 더 빠른 스토리지에 정보를 복사하고, 메인 메모리를 보조 스토리지의 캐시로 볼 수 있음
- Device Driver는 I/O를 관리하기 위한 각각의 디바이스 컨트롤러
    - 컨트롤러와 커널 사이에 획일적인 인터페이스를 제공
- 레지스터 <-> 캐시 <-> 메인 메모리 <-> solid-state dist <-> 하드 디스크 <-> optical disk(ex : CD) <-> magnetic tapes(ex : 테이프)
    - 우측으로 갈 수록 느리고 값이 싸짐

## <strong>캐싱</strong>
- 중요한 원리이고, 컴퓨터에서 많은 단계로 수행이 됨
    - 하드웨어, O/S, 소프트웨어 에서
- 사용중인 정보를 느린 스토리지에서 빠른 스토리지로 일시적으로 복사
- 우선 스토리지(캐시)를 더 빠르게 확인하여 정보가 있는지 체크
    - 있는 경우, 캐시에서 직접 사용되는 정보
    - 없는 경우 데이터가 캐시에 복사되어 캐시에 사용
- 캐시중인 스토리지보다 작은 캐시
    - 캐시관리 중요한 설계 문제
    - 캐시 사이즈와 대체 정책(?)

## <strong>Direct Memory Access Structure(DMA의 구조)</strong>
- 메모리 속도에 가깝게 정보를 전송할 수 있는 고속 IO장치에 사용
- CPU 없이 직접적으로 버퍼에서 메인 메모리까지의 데이터의 블럭으로 디바이스 컨트롤러를 옮김
- 유일한 인터럽트는 바이트당 인터럽트 보다 블럭당 생성됨
- 모든 수행 후 인터럽트

## <strong>현대 컴퓨터가 일하는 방법</strong>
- 폰 노이만 아키텍처 (Von Neumann Architecture)
    - 메모리에 프로그램과 데이터를 함께 넣어놓고, 차례로 불러내 처리하는 방식
    - 입력 데이터는 기억장치인 메모리에 저장되고, 중앙처리장치는 명령을 처리할 때, 메모리로부터 명령문과 입력 데이터를 불러들임
    - 중앙처리장치가 처리한 연산 결과는 다시 메모리에 저장
    - 이후 메모리에 있던 연산 결과가 모니터에 출력
    - 이와 같이 폰 노이만 아키텍처에서 중앙처리장치가 데이터를 처리하는 방식은 데이터를 메모리에서 가져오고, 처리 후 다시 메모리로 보냄
    - 이때 메모리에 올라온 명령문을 하나씩 차례로 처리
    - 데이터 저장을 위한 메모리와 프로그램 실행을 위한 메모리가 공통으로 사용되고 있고, 명령문을 하나씩 순차적으로 처리
- 입력 데이터가 메모리에 저장 -> 중앙처리장치가 메모리로부터 명령문과 데이터를 불러들임 -> 연산 후 다시 메모리에 저장 -> 메모리에 있는 정보 출력
- 코드 실행 시 값에 저장되는 경우 : int a, float b, . . . 값에 해당 데이터가 저장
- 코드 실행 시 주소에 저장되는 경우 : a = b + c . . . b와 c의 값을 a라는 주소에 저장

## <strong>컴퓨터 시스템의 구조</strong>
- 대부분의 시스템은 싱글 범용 프로세서를 사용
    - 대부분의 시스템은 특수한 목적의 프로세서도 존재
- 멀티프로세서 시스템의 사용과 중요성 증가
    - 병렬 시스템이라고도 하며, 강결합된 시스템이라고도 함
    - Tightly Coupled(강결합) 과 Loosely Coupleld(약결합)의 차이
        -  Tightly Coupled(강결합)
            - 각 프로세스마다 독립된 메모리를 각지 시스템으로, 분산처리 시스템이라고도 한다.
            - 둘 이상의 독립된 컴퓨터 시스템을 통신망(통신 링크)을 통하여 연결한 시스템이다.
            - 각 시스템마다 독자적인 운영체제를 가지고 있다.
            - 각 시스템은 독립적으로 작동할 수 있고, 필요한 경우에는 상호 통신을 할 수도 있다.
            - 프로세스 간의 통신은 메시지 전달이나 원격 프로시저 호출을 통해서 이루어 진다.
            - 각 시스템마다 독자적인 운영이 가능하므로 프로세서 간이 결합력이 약하다.
            - Loosely Coupled 방식보다 더 정확하다는 인식이 있다.
            - Loosely Coupled 방식보다 계산량이 더 많다는 인식이 있다.
            - 장점
                - 재료처리량을 증가 : 프로그램을 묶어서 한번에 사용 (많은 일 가능)
                - 신뢰성 증가
                - 경제적?? : 뒤에 갖다 붙이는 느낌?
        - Loosely Coupleld(약결합)
            - 동일 운영체제 하에서 여러 개의 프로세스가 하나의 메모리를 공유하여 사용하는 시스템으로 다중(병렬)처리 시스템이라고도 한다.
            - 하나의 운영체제가 모든 프로세스와 시스템 하드웨어를 제어한다.
            - 프로세스 간의 통신은 공유메모리를 통해서 이루어진다.
            - 하나의 메모리를 사용하므로 프로세서 간의 결합력이 강하다.
            - 공유 메모리를 차지하려는 프로세스 간의 경쟁을 최소화해야 한다.
            - 장점 : 엔지니어링 측면에서 자유도가 굉장히 높다.
            - 단점 : 특정 센서를 믿을 수 없을 때 어떻게 처리해야하는지 직접 설계해야한다.
    - Asymmetric Multi Processing(AMP)
        - 각 프로세서는 특정 작업을 할당
        - 두 개 이상의 각각의 프로세서가 자신만의 다른 특정 기능을 수행하는 아키텍쳐
    - Symmetric Multi Processing(SMP)
        - 각 프로세서는 모든 작업을 수행
        - 두 개 이상의 프로세서가 하나의 컴퓨터 시스템 아키텍쳐를 공유하도록 연결
        - 각각의 프로세서는 독립적으로 자신의 작업을 처리한다는 의미
## <strong>클러스터 시스템</strong>
- 멀티프로세서 시스템과 비슷하지만, 여러 시스템이 함께 작동
    - 보통 storage-area network(SAN)을 통해 스토리지를 공유
    - 오류가 발생 하더라도 높은 가용성의 서비스를 제공
        - Asymmetric clustering는 hot-standby mode의 시스템 존재
        - Sysmmetric clustering는 에플리케이션을 실행하고, 서로 모니터링을 하는 여러 노드가 존재
    - 일부 클러스터는 high-performance computing(HPC)를 갖기 위함
        - 병렬화가 되기 위해서는 애플리케이션이 작성되야함
    - 일부는 충돌하는 작업을 방지하기 위해서 distributed lock manager(DLM)을 가짐
## <strong>O/S 구조</strong>
- 효율성을 위해 필요한 멀티프로그래밍(Batch system) -> 데이터를 모아서 처리 (ex : 연말 정산과 같은 개념)
    - 사용자는 CPU와 I/O디바이스를 항상 사용중으로 유지할 수 없음
    - 멀티프로그래밍 프로그램(code and data)을 구성하여 CPU에 항상 실행 할 작업이 있음
    - 시스템의 전체 작업 중 일부가 메모리에 저장 됨
    - 작업을 예약하여 하나의 작업을 선택하고 실행
    - 대기중엔 다른 작업으로 전환 됨
- Timesharing(mumtitasking)는 CPU가 작업을 너무 자주 전환하여 사용자가 실행 중인 각 작업과 상호 작용하여 대화형 컴퓨팅을 생성할 수 있는 논리적 확장
    - mumtitasking : Batch system에 비해 빠름 -> 시간을 굉장히 빠르게 나눠서 동시에 하는 것 처럼 보임 (일부만 조금씩 빠르게 해결)
    - 응답시간은 1초보다 빨라야함
    - 각 사용자는 메모리에서 실행중인 프로그램을 하나 이상 보유 -> 프로세스
    - 여러 작업을 동시에 실행 할 준비가 된 경우 -> CPU스케줄링
    - 프로세스가 메모리에 맞지 않는 경우, 스왑을 통해 프로세스가 실행되도록 이동
    - 가상의 메모리를 사용하여 메모리에 포함되지 않은 프로세스를 실행
## <strong>O/S Operations</strong>
- 인터럽트 드리븐(하드웨어 and 소프트웨어)
    - 한 장치에 의한 하드웨어 인터럽트
    - 소프트웨어 인터럽트(exception or trap)
        - 소프트웨어 에러 (division by zero)
        - 운영체제 서비스 요청 (open file . . .)
        - 다른 프로세스 문제로는 무한 루프, 프로세스 상호 수정 또는 운영 체제 등 존재
    - 미시적 : 능동적 / 수동적인 인터럷트 구분 필요
    - 거시적 : 운영체제의 주요 하는 일 4가지
        - Process management : Process가 일을 하고 기다리는 행위를 관리
        - memory management : 각 메모리를 할당해주는 일
        - device management : 각기 다른 디바이스(입출력장치)를 제조회사가 만든 드라이브를 통해 동일한 신호를 사용하여 운영체제로 전달
        - file management : 실제 file의 모습과 사람이 보는 file의 모습이 다름으로 이러한 것을 해결해주는 일
- 듀얼 모드 작동을 통해 OS는 자신과 다른 시스템 구성 요소를 보호할 수 있음
    - 유저 모드와 커널 모드
    - 하드웨어에서 제공하는 비트 모드
        - 시스템이 사용자 코드 또는 커널 코드를 실행 중인지 구별하는 기능 제공
        - 권한이 있는 것으로 지정된 일부 명령은 커널 모드에서만 실행 가능합니다
        - 시스템 콜이 커널 모드로 변경되고 호출에서 복귀하면 사용자로 재설정
            - System call : open, close, read, wrtie
- 멀티 모드 작업을 지원하는 CPU가 증가
    - i.e. VMs의 가상 장치 관리(virtual machine manager_VMM)모드

## <strong>사용자에서 커널 모드로 전환</strong>
- 무한 루프/프로세스 호깅 리소스를 방지하기 위한 타이머
    - 타이머가 일정 시간 후에 컴퓨터를 중단하도록 설정
    - 실제 클럭으로 감소된 카운터 유지
    - 운영 체제에서 카운터 설정(특권 지침)
    - 카운터 0이 인터럽트를 생성할 때
    - 스케줄링 전에 설정하여 할당된 시간을 초과하는 프로그램을 다시 제어하거나 종료
        - 스케줄링 : 현재 진행중인 작업 후 메모리에 순서대로 입력된 데이터가 아닌 효율적인 처리가 가능한 데이터 우선 처리
<img width="599" alt="image" src="https://user-images.githubusercontent.com/99342700/229978778-0854b0e9-085c-4cde-bb60-10a97fbe046c.png">

## <strong>Process management(프로세스 관리)</strong>
- 프로세스는 실행 프로그램이다.
- 프로세스는 시스템 내의 작업 단위이다.
- 프로그램은 수동적이고, 프로세스는 능동적이다.
- 프로세스는 작업을 수행하기 위한 리소스를 필요로 한다.
    - 4가지의 리소스 : CPU, Memory, I/O, files
    - 초기화 데이터
- 프로세스 종료시 재사용 가능한 리소스 회수가 필요
- 단일 스레드 프로세스에는 실행할 다음 명령의 위치를 지정하는 하나의 프로그램 카운터 가지고 있다.
    - 프로세스는 한 번에 하나씩 순차적으로 명령을 실행하고 완료한다.
- 멀티 스레드 프로세스는 스레드당 하나의 프로그램 카운터를 가지고 있다.
- 일반적으로 시스템에는 하나 이상의 CPU에서 동시에 실행되는 많은 프로세스, 일부 사용자 및 일부 운영 체제가 있습니다
    - 프로세스와 스레드 사이에 CPU를 다중화 하여 동시성 제공
    - CPU 다중화 : 한 사람이 동시에 여러 행동을 하는 것 (ex: 티비를 보면서 전화, 컴퓨터 등 같이 사용)

## <strong>Process Management Activities</strong>
- 운영체제는 프로세스 관리와 관련하여 다음 활동을 담당함
    - 사용자와 시스템 프로세스 모두 생성과 삭제
    - 프로세스 일시 중단 및 재개 (이를 스케줄링 이라고 함)
    - 프로세스 동기화 메커니즘 제공
    - 프로세스 커뮤니케이션 메커니즘 제공
    - deadlock handling 메커니즘 제공 (교착상태 처리)

## <strong>Memory Management</strong>
- 프로그램을 전부 또는 일부를 실행하기 위해서는 메모리에 있어야 함
- 프로그램으로 부터 필요로 하는 전부 또는 일부의 데이터는 메모리에 있어야 함
- 메모리 관리는 언제 메모리에 있는지 무엇이 있는지를 결정함
    - 꼭 필요한 데이터가 메모리에 올라가있음
- 메모리 관리 활동
    - 현재 메모리의 어떤 부분이 누구에 의해 사용되고 있는지 추적
    - 메모리로 또는 메모리에서 이동 할 프로세스(혹은 일부) 데이터 결정
    - 필요에 따라 메모리 공간 할당 또는 할당 헤제

## <strong>Storage Management (File_01)</strong>
- OS는 정보 스토리지의 논리적인 관점에 대해 일관되게 제공
    - 컴퓨터에서 매우 중요한 로지컬, 피지컬 관점
    - 물리적인 속성을 논리적인 스토리지 유닛으로 추상화
        - file : 피지컬 프로퍼티를 추상화 함
    - 각 매체는 장치에 의해 제어됨 (ex : disk drive, tape drive . . .)
        - 액세스 속도, 용량, 데이터 전송 속도, 액세스 방법(순차 또는 무작위) 등 다양한 속성
        - 다양한 피지컬 프로퍼티를 앱스트랙트 한다는 의미를 예로 설명
            - 하드 디스크를 읽을때나 USB파일을 읽을때나 동일
- file의 본질에 대한 설명
    - 복잡 / 다양한 종류의 파일 저장 장치 : 컴퓨터
    - 단순 / 일원화된 파일의 모습 : user

## <strong>File-System Managemnet (File_02)</strong>
- 일반적으로 디렉토리로 구성된 파일
- 대부분의 시스템에서 액세스 제어 기능을 사용하여 액세스할 수 있는 사용자 결정
- OS에 포함된 활동
    - 파일과 디렉토리를 생성하고 삭제함
    - 파일 및 문서를 조작하기 위한 기본 요소
    - 보조스토리지에 파일 매핑
        - 매핑이라는 의미
            - 가상 메모리 주소를 물리적인 메모리 주소로 변환하여 해당 주소에 있는 데이터에 접근하게 하는 것
            - 가상 메모리 주소 공간과 물리적인 메모리 주소 공간의 일대다 대응 가능
                - 일대일 매핑 : 가상 메모리와 물리 메모리가 완전히 일치하는 경우
                - 일대다 매핑 : 가상 메모리 주소 공간에서 여러 개의 주소가 물리 메모리 주소 공간에서 하나의 주소에 대응하는 경우
            - 매핑은 가상 메모리의 장점인 프로그램의 안전성, 보안성, 효율성 등을 실제 물리 메모리에 반영할 수 있게 해주는 아주 중요한 역할
            - 안정적인(비휘발성) 스토리지 미디어에 파일 백업
- 사용자가 원하는대로 구성이 가능하게 만들어줌 : 생성, 수정, 삭제 등등 . . .

## <strong>Mass-Storage Management</strong>
- 일반적으로 디스크는 기본 메모리에 맞지 않는 데이터나 "오래" 보관해야 하는 데이터를 저장하는 데 사용 (크거나 영구적 보관)
- 적절한 관리가 가장 중요
- 컴퓨터 작동의 전체 속도는 디스크 서브시스템과 그 알고리즘에 달려 있습니다
    - 힌지 : 스토리지에서 속도가 가장 느림
- OS의 활동
    - 여유 공간 관리
    - 저장공간 할당
    - 디스크 스케줄링
        - 프로세서 스케줄링과 차이점 : 스케줄링은 요청 순서 보다는 효율적인 순서로 작업
- 일부 스토리지는 빠르지 않아도 상관 없음
    - 3차 스토리지는 optical 스토리지와, 마그네틱 테이프를 포함
    - 여전히 OS또는 어플리케이션에 의해 관리 되어야만 함
    - WORM(write - once, read - many - times)와 RW(read - write)사이에 차이가 있음

## <strong>다양한 수준의 스토리지 성능</strong>
- 스토리지 계층 레벨 간의 이동은 명시적이거나 암시적일 수 있음

## <strong>디스크에서 레지스터로 "A"데이터의 이동</strong>
- 멀티태스킹 환경에서는 스토리지 계층에서 저장된 위치에 관계없이 최신 값을 사용하도록 주의
<img width="565" alt="image" src="https://user-images.githubusercontent.com/99342700/232045482-6fe5076f-9a61-40e8-bc9a-e00c5e2f9bfe.png">

- 멀티프로세서 환경은 모든 CPU가 캐시에서 최신 값을 가질 수 있도록 하드웨어의 캐시 일관성을 제공
    - cache coherency(캐시 일관성) : 공유 메모리 시스템에서 각 클라이언트(혹은 프로세서)가 가진 로컬 캐시 간의 일관성을 의미
- 환경이 분산되는 상황이 더욱 복잡함
    - 데이터의 여러 복사본이 존재 할 수 있음
    - Chapter 17에서 다루는 다양한 솔루션

## <strong>I/O 서브시스템</strong>
- OS의 한 가지 목적은 사용자로부터 하드웨어 장치의 특성을 숨기기 위함
- OS 서브시스템의 역할
    - buffering(데이터를 전송하는 동안 일시적으로 저장), caching(성능 향상을 위해 데이터의 일부를 더 빠른 스토리지에 저장), spooling(한 작업의 출력과 다른 작업의 입력이 중복됨)을 포함한 I/O의 메모리 관리
    - 일반적인 디바이스-드라이버의 인터페이스
    - 특정한 하드웨어 장치용 드라이버

## <strong>보호 및 보안</strong>
- Protection(보호) - OS에 의해 정의된 리소스에 대한 프로세스 또는 사용자의 액세스를 제어하는 모든 메커니즘
- Security(보안) - 내부 및 외부 공격에 대한 시스템 방어
    - 서비스 거부, 경고, 바이러스, 신원 도용, 서비스 도난 등 다양한 범위
- 시스템은 일반적으로 먼저 사용자를 구별하여 누가 무엇을 할 수 있는지 결정
    - 사용자 ID(or 보안 ID)에는 사용자당 하나씩 이름 및 관련 번호가 포함
    - 사용자 ID를 모든 파일과 연결하고 해당 사용자의 프로세스를 통해 액세스 제어를 결정
    - 그룹 식별자(그룹 ID)를 사용하면 사용자 집합을 정의하고 관리를 제어할 수 있으며 각 프로세스, 파일과도 연결
    - 권한 상승을 통해 사용자는 더 많은 권한을 가진 유효한 ID로 변경 가능

## <strong>커널 데이터의 구조(O/S Program)</strong>
- 표준 프로그래밍 데이터 구조와 유사함
<img width="632" alt="image" src="https://user-images.githubusercontent.com/99342700/232185106-429f3787-110a-4110-9d7e-c1bc9c672cd8.png">

- 이진 탐색 트리 -> 속도 효율이 좋음 (정보를 빨리 찾고 해결)
    - left <= right
    - 실행 시간 : O(n)
    - 벨런스 이진 트리는 O(log n)
    <img width="251" alt="image" src="https://user-images.githubusercontent.com/99342700/232185189-4a22bec2-7bbb-43ff-9f10-6283f104c5a1.png">

- Hash함수는 hash map을 만들 수 있음
<img width="427" alt="image" src="https://user-images.githubusercontent.com/99342700/232185255-9a9a7117-c60d-4986-8c28-6e75885e0d18.png">

- 비트맵 : n개 항목의 상태를 나타내는 n개의 이진 숫자 문자열 (이진수)
- 리눅스 데이터 구조는 (include files <linux/list.h>, <linux/kfifo.h>, <linux/rbtree.h>)파일에 포함 됨

## <strong>컴퓨터 환경</strong>
- 컴퓨터 환경 : Traditional(기존의)
    - 우리가 알고 있는 일반적인 컴퓨터
    - 일반적으로 실행되는 장치의 목적
    - 그러나 대부분의 시스템이 다른 시스템과 상호 연결됨에 따라 흐려짐 (ex : 인터넷)
    - 포털(Portals)은 내부 시스템에 대한 웹 액세스를 제공
    - 네트워크 컴퓨터(씬 클라이언트)는 웹 터미널과 같음
    - 무선 네트워크를 통한 모바일 컴퓨터의 상호 연결
    - 네트워킹이 유비쿼터스화됨
        - 가정용 시스템에서도 방화벽을 사용하여 인터넷 공격으로부터 가정용 컴퓨터를 보호합니다
        - 유비쿼터스 : 사용자가 시간·장소에 구애받지 않고 자유롭게 네트워크에 접속할 수 있는 정보통신 환경
    - 휴대용 스마트폰, 테블릿 등등 . . .
    - 기존의 노트북과 기능적으로 어떠한 차이가 있는가?
    - 추가 기능 - 더 많은 OS 기능 (GPS, gyroscope)
    - 증강 현실과 같은 새로운 유형의 앱을 허용
    - 무선 IEEE 802.11 사용하거나 연결을 위한 셀룰러 데이터 네트워크를 사용함
    - 대표적으로 Apple IOS, Coogle Android가 있음

- 컴퓨터 환경 : Distributed (분산된)
        - Distributed란 정의 및 네트워크를 통해서
        - 서로 네트워크로 연결된 이질적인 개별 시스템 모음
            - 네트워크가 통신 경로이며, TCP / IP가 가장 일반적
                - Local Area Network (LAN)
                - Wide Area Network (WAN)
                - Metropolitan Area Network (MAN)
                - Personal Area Network (PAN)
        - 네트워크 운영체제는 네트워크를 통해 시스템간에 기능을 제공
            - 통신체계를 통해 시스템이 메세지를 교환 할 수 있음
            - 단일 시스템에 대한 환상 (일루전의 정의, 버츄얼 머신)

- 컴퓨터 환경 : Client-Server
    - Client-Server Computing
        - 스마트 PC로 대체된 Dumb 단말기
        - 많은 시스템이 이제 서버를 통해 클라이언트가 생성한 요청에 응답
            - 컴퓨터 서버 시스템은 서비스를 요청하기 위한 클라이언트 인터페이스를 제공 (ex : database . . .)
            - 파일 서버 시스템은 클라이언트가 파일을 저장하고 검삭하기 위한 인터페이스를 제공
        <img width="398" alt="image" src="https://user-images.githubusercontent.com/99342700/232190217-b6884498-40e2-4bb3-914d-d89bcb670761.png">

- 컴퓨터 환경 : Peer-to-Peer (P2P)
    - 분산된 시스템의 또 다른 모델
    - P2P는 서버와 클라이언트를 구별하지 않음
        - 대신 모든 노트가 peer로 간주 됨
        - 각각 클라이언트, 서버 또는 둘 다 역할 수행 가능
        - 노트는 P2P네트워크와 합쳐져야 함
            - 네트워크의 중앙 검색 서비스에 서비스를 등록
            - 서비스 요청 브로드캐스트 및 검색 프로토콜을 통한 서비스 요청 응답
            - 예를 들어 Napster 및 Gnutella, Skype와 같은 VoIP(Voice over IP) 등이 있음

- 컴퓨터 환경 : Virtualization
    - 학기 말에 이해 (어려움)

- 컴퓨터 환경 : Cloude Computing
    - 네트워크를 통해 컴퓨팅, 스토리지, 애플리케이션까지 서비스로 제공
    - 가상화를 기본 기능으로 사용하기 때문에 가상화의 논리적 확장
        - Amazon EC2에는 수천 대의 서버, 수백만 대의 가상 머신, 인터넷을 통해 사용할 수 있는 페타바이트급 스토리지가 있으며 사용량에 따라 비용을 지불
    - 많은 형태들
        - Public cloud - 인터넷을 통해 누구나 지불 가능
        - Private cloud - 회사가 회사를 위해 운영
        - Hybrid cloud - public cloud, private cloud의  둘 다 포함
        - Software as a Service(SaaS) - 한 개 또는 그 이상의 어플리케이션은 인터넷을 통해 이용할 수 있음(ex : word processor)
        - Platform as a Service(PaaS) - 인터넷을 통해 애플리케이션을 사용할 수 있는 소프트웨어 스택
        - Infrastructure as a Service(IaaS) - 서버 또는 저장소는 인터넷을 통해 사용
    - 기존 OS와 VMM, 클라우드 관리 툴로 구성된 클라우드 컴퓨팅 환경
        - 인터넷 연결에는 방화벽과 같은 보안이 필요
        - Load balancer가 traffic을 여러 애플리케이션에 분산시킵니다
        <img width="354" alt="image" src="https://user-images.githubusercontent.com/99342700/232193355-e1e58f6b-9504-4305-aa34-ec741f8c2564.png">

- 컴퓨터 환경 : Real - Time Embedded Systems
    - 가장 널리 사용되는 컴퓨터 형태의 실시간 임베디드 시스템
        - real-time OS
        - 확장 사용
    - 다른 수 많은 특수한 컴퓨터 환경도 마찬가지임
        - 일부는 OS를 사용하고, 일부는 OS없이 작업을 수행
    -  실시간 OS에 명확한 고정 시간 제약이 있음
        - 제약 조건 내에 처리 해야 함
        - 제약 조건이 충족된 경우에만 올바르게 작동

## <strong>Open-Soure Operating Systems</strong>
- 단순히 binary closed-source가 아닌 소스코드 형식으로 OS를 제공
- 복사 방지 및 DRM(Digital Dights Management) 이동에 대한 대응
- "copyleft"GPL(GNU Public License)을 가진 FSF(Free Software Foundation)에서 시작 됨
- 예를들어 GNU/Linux와 BSD UNIX(including core of Mac OS X) 그리고 수 많은 것들이 포함 됨
- VMM을 VMware Player(Free on Windows), Virtualbox 처럼 사용할 수 있음
- 탐색을 위해 게스트 운영 체제를 실행하는 데 사용

