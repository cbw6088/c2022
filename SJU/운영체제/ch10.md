## <strong>가상 메모리(Virtual Memory)</strong>
- 물리적인 메모리 크기보다 더 큰 크기의 프로그램을 실행시키기 위한 기술
- 가상 메모리 기술은 파일 공유와 라이브러리, 프로세스 생성과 같은 효율적인 메커니즘을 제공
- 다음 그림은 물리적인 메모리 크기 보다 큰 가상 메모리
    - 가상 메모리에 올라간 페이지들을 메모리 맵을 통해서 물리적인 메모리 공간에 매핑
    - 실제 물리적인 메모리에 올라간 페이지들을 제외한 나머지 페이지들은 보조기억장치인 Backing Store에 저장
<img width="719" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/3725638e-33ae-4ee3-b4fc-de96c54d9ad7">

- 가상 메모리의 페이지 공유(Page Sharing) 기술을 통하여 2개 이상의 프로세스에 의해서 파일과 메모리를 공유하는 것을 허용
- 다음 그림은 가상 메모리 기술을 사용하여 라이브러리를 공유하는 프로세스를 표현
<img width="723" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/689195a6-2077-4240-b399-dbba4ecc8240">

### <strong>가상 주소 공간(Virtual Address Space)</strong>
- 가상 주소 공간은 프로세스가 메모리에 어떻게 저장되는지 방법에 대한 논리적(또는 가상의) 뷰
- 논리적 주소는 0부터 시작하고 이 가상 주소 공간은 연속적인 메모리에 올린 것 처럼 존재
<img width="231" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/81feecf6-a919-48bf-8eba-0b9b94f7da6e">

## <strong>디맨드 페이징(Demand Paging)</strong>
- 프로그램을 실행하기 위해서는 보조기억장치에서 메모리로 적재하는 작업이 수행되어야 함
- 프로그램 전체를 물리적인 메모리에 적재하는 것은 첫 번째 옵션
- 디맨드 페이징은 실행중에 요청할 때만 페이지를 적재하는 전략
- 디맨드 페이징은 가상 메모리 시스템에서 일반적으로 사용

### <strong>디맨드 페이징의 개념</strong>
- 프로세스가 실행중일 때 몇몇 페이지들은 메모리에 있을 것이고, 몇몇 보조기억장치에 있음
- 페이지들이 메모리에 있는지 보조기억장치에 있는지 표시하기 위해서 valid-invalid bit를 사용
    - Valid : 페이지가 메모리에 존재
    - Invalid : 페이지가 유효하지 않은 페이지이거나 보조기억장치에 존재
<img width="744" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/77e278d3-2448-4fb2-84ea-0356b5a3653c">

- 위 그림을 보면 A페이지의 페이지 번호는 0번이고, 물리적인 메모리인 4번 프레임에 저장이 됨
- 페이지 테이블에서 0번의 valid-invalid bit가 v이므로, A페이지는 물리적 메모리에 존재함을 알 수 있음
- ex) 6번 페이지인 G가 페이지 테이블에서 valid-invalid bit가 i이면 페이지 G는 보조기억장치에 있다는 것을 의미
- 이렇게 페이지가 보조기억장치에 있는 상황을 <strong>Page Fault</strong>라고 함

### <strong>Page Fault처리 수행 과정</strong>
- 해당 페이지가 유효한지 유효하지 않은 메모리 접근인지 판단하기 위해서 내부 테이블을 확인
- 만약 페이지가 유효한 경우에는 그대로 처리해주면 되고, 유효하지 않은 페이지라면 Page Fault이므로 해당 페이지를 보조기억장치에서 메모리에 올려야 함
- free-frame리스트를 사용하여 비어있는 프레임을 탐색
- 보조기억장치로 가서 올리고자 하는 페이지를 읽어서 새롭게 할당된 프레임에 스케줄링
- 보조기억장치를 읽는 것이 완료되면 내부 테이블과 페이지 테이블을 지금 메모리에 페이지가 있다고 수정
- 다시 프로세스를 재개
<img width="783" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/1a39dcdd-6c50-4197-a2f1-725108d25ca6">

1. 특정 메모리를 접근하기 위해서 페이지 테이블을 참조
2. 해당 페이지 참조가 유효하지 않으므로 운영체제에 의해서 트랩(trap) 됨
3. 운영체제는 Backing Store(보조기억장치)로 이동
4. 보조기억장치에 있는 페이지를 물리적인 메모리의 비어있는 프레임에 적재
5. 페이지 테이블에서 해당 페이지 번호의 valid-invali bit를 i에서 v로 변경
6. 프로세스 실행을 재개

### <strong>순수한 디맨드 페이징(Pure Demand Paging)</strong>
- 순수한 디맨드 페이징은 페이지가 필요할 때까지는 절대로 페이지를 메모리에 가져오지 않는 것을 의미
- 순수한 디맨드 페이징을 사용하게 되면 메모리에 페이지가 없는 상태에서 프로세스를 실행시킬 수 있음
- 운영체제가 프로세스를 실행시키고자 할 때 페이지 폴트가 발생하게 되고 필요한 페이지를 보조기억장치에서 메모리로 적재하여 수행
- 순수한 디맨드 페이징은 필요할 때 마다 페이지를 보조기억장치에서 적재시키기 때문에 시간이 많이 듬

### <strong>참조 국부성(Locality of Reference)</strong>
- 만약 어떤 한 프로그램이 다수의 새로운 페이지에 접근한다면 이 페이지들은 하나의 명령어가 있는 페이지이고, 다수의 데이터를 위한 페이지라고 가정
- 하나의 명령어 페이지가 여러 개의 페이지 폴트를 일으킬 수 있음
- 하지만, 다행히 실행중인 프로세스들에게는 이러한 경우가 많지 않음
- 프로그램들은 참조 국부성이 있기 때문에 디맨드 페이징으로 이유있는 성능을 낼 수 있음
```c++
int row, col;
int [128][128] data;

for(col = 0; col < 128; col++){
    for(row = 0; row < 128; row++){
        data[row][col] = 0;
    }
}
/* 위 코드의 data 2차원 배열은 1행에 128개의 열을 가지고 있고, 이러한 행이 128개 존재*/
/*여기서 배열 특성은 연속적으로 저장되기 때문에 하나의 행을 한 개의 페이지로 표현 가능*/
/*그러나 위 코드의 2차원 배열은 data[0][0] -> data[1][0] -> data[2][0] 순으로 참조되기 때문에 페이지 폴트가 여러 번 발생*/
/*최악의 경우 128번의 페이지 폴트 가능성이 존재*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int row, col;
int [128][128] data;

for(row = 0; row < 128; row++){
    for(col = 0; col < 128; col++){
        data[row][col] = 0;
    }
}
/*위 코드도 마찬가지로 한 갱의 행이 하나의 페이지로 표현되지만 이전 코드와는 다르게 data[0][0] -> data[0][1] -> data[0][2] 순으로 참조*/
/*그렇기 때문에 한 개의 페이지를 전부 다 사용한 다음에 다음 페이지(다음행)를 참조*/
/*페이지 폴트가 일어나지 않을 가능성이 높음*/
```

### <strong>디맨드 페이징을 위한 하드웨어의 지원</strong>
- 페이지 테이블(Page Table)
    - 페이지 테이블은 valid-invalid bit를 사용하여 해당 페이지가 유효한지 아닌지 표시하는 기능을 가지고 있음
- 보조기억장치(교환을 위한 공간, swap space)
    - 사용하지 않는 페이지들을 보조기억장치에 저장하고 필요한 경우에는 메모리로 적재하는데 사용

### <strong>명령어 재개(Instruction Restart)</strong>
- Instruction Restart는 디맨드 페이징을 위한 중요한 요구조건이고, 페이지 폴트 이후에 명령어를 재개시키기 위한 기능
- 페이지 폴트가 발생하면 인터럽트 된 프로세스의 상태(Registers, Condition Code, Instrunction Counter 등)를 저장
- 만약 명령어 인출(Instruction fetch) 할 때 페이지 폴트가 발생하면 명령어 인출을 다시 인출을 함으로써 재개
- 만약 연산자(Operand)를 인출하는 동안 페이지 폴트가 발생하면 인출과 디코드 명령어를 다시 한 다음에 연산자를 인출
- 최악의 경우 예제
    - ADD(A, B, C); 와 같은 명령어가 있을 때 수행과정은 다음과 같음
        1. ADD명령어를 인출 및 해독
        2. A인출
        3. B인출
        4. A와 B를 더함
        5. C에 합계를 저장
    - 위 수행 과정에서 어느 단계 중에서 페이지 폴트가 발생하면 다시 재개할 때는 1번부터 다시 시작

### <strong>Free Frame List</strong>
- 페이지 폴트가 발생할 때 운영체제는 보조기억장치에서 메모리로 요청 받은 페이지를 적재해야 함
- 페이지 폴트를 해결하기 위해서 운영체제는 Free Frame List를 유지관리 함
- Free Frame List는 페이지 요청을 만족시키기 위한 비어있는 프레임의 풀
- Free Frame 또한 스택이나 힘 세그먼트가 확장 될 때 할당되어야 함
<img width="607" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/1b401a46-a221-4c89-8eb5-edde64d49922">

### <strong>디맨드 페이징의 성능에 영향을 미치는 요소</strong>
- ma    : 메모리 접근 시간
- p     : 페이지 폴트가 일어날 확률
    - EAT = (1 - p) * ma + p * (page fault time, 페이지 폴트 처리 시간) = Effective Access Time
- 페이지 폴트를 처리하는데 필요한 시간
    - 페이지 폴트때문에 인터럽트 걸어주는 시간
    - 페이지 읽는 시간(대부분의 시간 소요)
    - 프로세스 재개하는 시간
- 예를 들어 페이지 폴트 처리의 평균 시간이 8밀리초이고, 메모리 접근 시간이 200나노 초라고 가정하면 다음과 같음
    - p = 0.001 : 페이지 폴트가 1000번 중에 한 번 일어나는 경우
    - EAT = (1 - p) * 200 + p * 8,000,000 = 200 + 7,999,800 * p = 8199.8 ~= 8.2밀리초

## <strong>Copy-On-Write</strong>
- Copy-On-Write는 Write 할 때 Copy하자는 의미로 어떤 한 프로세스가 공유 페이지를 작성할 때만 해당 공유페이지를 복사하자는 의미
- 아래의 그림은 프로세스1이 페이지 C를 수정하기 전과 수정한 후
    - 아래의 그림에서 프로세스1이 복사(Fork)되어 프로세스2가 생겼을 때 공유 페이지에 무언가 작성을 하지 않는다면 물리적인 메로리 위에 있는 같은 페이지를 가리켜도 상관 없음
    - 그러나 페이지C를 수정하였다면 프로세스1과 프로세스2는 페이지 C를 복사한 디음에 다르게 가리켜야 함
<img width="777" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/3bc6b756-dce4-4192-8017-ebbb56cde090">

- 아래의 그림은 프로세스1이 페이지C에 있는 값을 변경하였기 때문에 페이지C를 복사한 다음에 값을 수정하고 복사된 페이지C를 가리키는 모습
<img width="782" alt="image" src="https://github.com/cbw6088/c2022/assets/99342700/41eb11f5-a840-47cb-ab03-07af9ba3eb1b">

## <strong>Virtual Memory Quiz</strong>
1. (연습문제 10.3) 다음 페이지 교체 알고리즘들 중에서 Belady's anomaly현상을 겪지 않는 알고리즘은?
- <strong>a. LRU replacement (O)</strong>
- b. FIFO replacement
- <strong>c. Optimal replacement (O)</strong>
- d. Second-change replacement

2. (연습문제 10.8) 다음 페이지 참조 문자열을 고려합니다:
<br>1, 2, 3, 4, 5, 3, 4, 1, 6, 7, 8, 7, 8, 9, 7, 8, 9, 5, 4, 5, 4, 2.
<br>다음 교체 알고리즘의 경우 네 개의 프레임을 가정할 때 몇 개의 페이지 결함이 발생합니까? 처음에는 모든 프레임이 비어 있으므로 처음에 고유한 페이지에 오류가 하나씩 발생합니다.
<br>a. LRU repacement b. FIFO replacement c. Optimal replacement
<br> Answer : a = 10, b = 10, c = 10

3. (연습문제 10.9) 다음 페이지 참조 문자열을 고려합니다:
<br>7, 2, 3, 1, 2, 5, 3, 4, 6, 7, 7, 1, 0, 5, 4, 6, 2, 3, 0 , 1
<br>3개의 프레임이 있는 demand paging을 가정하면, 다음 교체 알고리즘에서 몇 개의 page faults가 발생합니까?
<br>a. LRU repacement b. FIFO replacement c. Optimal replacement
<br> Answer : a = 11, b = 12, c = 13

4. (연습문제 10.36) 어떤 시스템이 demaned paging을 도입했는데, 페이징 디스크의 평균 엑세스 시간이 20millisecond 라고 하자. 페이지 테이블은 메인 메모리에 저장이 되어있고, 메인 메모리 액세스 시간은 1 microsecond라고 하자. 페이지 테이블을 통한 각 메모리의 참조는 2 microsecond가 걸리게 될 것이다. 여기에 TLB를 추가했고, TLB hit ratio는 80%로 측정되었다. TLB miss가 발생하는 20%의 10%(즉, 전체의 2%)는 페이지 폴트가 발생한다.
<br>이 시스템에서 유요한 메모리 접근 시간(EAT)가 가장 근사한 값은 얼마인가?
<br> Answer : 0.4 millisecond

5. (연습문제 10.29) 다음과 같은 시간 측정된 활용률을 가진 수요 페이징 시스템을 고려해 보십시오:
<br>CPU 활용률: 20% 페이징 디스크: 97.7% 기타 I/O 장치: 5%
<br>다음 각 항목에 대해 CPU 활용률을 향상시킬 것인지(또는 향상시킬 것인지)를 지정합니다.
<br>디맨드 페이징 시스템에서 시스템 측정 결과가 위와 같이 나올 때, 아래의 전략 중 CPU unilization을 향상시킬 수 없을 것 같은 전략으로만 묶인 것은?

- a. Install a faster CPU
- <strong>b. Install more main memory (O)</strong>
- c. Install a bigger paging disk
- d. Increase the page size
- <strong>e. Decrease the degree of multiprogramming (O)</strong>

6. 페이지 폴트가 계속적으로 너무 자주 발생하게 되어 프로세스의 실행 시간보다 페이지 교체를 하는 시간이 더 많아지는 현상과 가장 관련이 높은 것은?
- a. 외부 단편화 (external fragmentation)
- b. 프로그램의 국부성 (the locality or programs)
- <strong>c. 쓰레싱(thrashing) (O)</strong>
- d. 역전 페이지 테이블(Inverted Page Table)

7. 다음 중 가상 메모리(Virtual Memory)에 대한 설명으로 가장 틀린 것은?
- a. 가상 메모리를 사용하면 물리적 주소 공간의 크기는 가상 주소 공간의 크기보다 더 작아도 문제가 없다.
- b. 가상 주소 공간에서의 주소와 물리적 주소 공간에서의 주소 공간은 서로 독립적이다.
- <strong>c. 디맨드 페이징을 적용하여 여러 페이지를 분산하여 메모리에 적재하므로 실행 속도가 훨씬 빠르다. (O)</strong>
- d. 가상 메모리를 도입하면 하나의 프로세스의 크기가 물리적인 메모리 용량보다 더 커도 문제가 없다.

8. 프로그램의 국부성(the locality of program)에 대한 설명으로 가장 옳지 않은 것은?
- a. 반복 횟수가 많은 for문을 자주 사용하면 국부성이 높아진다고 할 수 있다.
- b. 프로그램의 국부성이 높을수록 디맨드 페이징을 사용하는 시스템의 성능은 좋아진다.
- <strong>c. 자주 사용하는 전역변수들은 heap영역에서 가급적이면 넓게 분포하도록 하면 프로그램의 효율을 올릴 수 있다. (O)</strong> 
- d. 가상 메모리를 사용하지 않고 Contiguous Memory Allocation을 하는 시스템이라면 프로그램의 국부성은 성능과의 관련이 많지 않다.