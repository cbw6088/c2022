# <strong>합병정렬</strong>

### 분할통치법 
- 분할통치법 : 일반적인 알고리즘 설계 기법의 일종
    1. 분할(divide) : 입력 데이터 L을 둘 이상의 분리된 부분집합 L1, L2, ... 으로 나눈다.
    2. 재귀(recur) : L1, L2, ... 각각에 대한 부문제를 재귀적으로 해결한다.
    3. 통치(conquer) : 부문제들에 대한 해결을 합쳐 L의 해결을 구한다.
- 재귀의 베이스 케이스 : 상수 크기의 부문제들
- 점화식을 사용하여 분석
- 예 : 합병정렬, 퀵 정렬

### 합병 정렬
- 합병 정렬 : 분할통치법에 기초한 정렬 알고리즘
- 힙 정렬 처럼
    - 비겨에 기초한 정렬
    - O(nlogn)시간에 수행
- 힙 정렬과는 달리
    - 외부의 우선순위 큐를 사용하지 않는다.
    - 데이터를 순차적 방식으로 접근(따라서 디스크의 데이터를 정렬하기에 적당)
- n개의 원소로 이루어진 입력 리스트 L에 대한 합병 정렬의 세 단계
    1. 분할 : 무순리트스 L을 각각 n/2개의 원소를 가진 두 개의 부리스트 L1과 L2로 분할
    2. 재귀 : L1과 L2를 각각 재귀적으로 정렬
    3. 통치 : L1과 L2를 단일 순서리스트로 합병
- 두 개의 정렬 리스트 합병하기 (통치 : merge-sort)  
    - merge-sort의 통치 단계 : 두 개의 정렬된 리스트 L1과 L2를 L1과 L2의 원소들의 합을 포함하는 정렬 리스트 L로 합병하는 과정
    - 각각 n/2개의 원소를 가지며, 이중연결리스트로 구현된 두 개의 정렬 리스트를 합병하는데 O(n시간 소요)

### 합병 정렬 분석
- 합병 정렬 트리의 높이 h : O(log n)
    - 각 재귀호출에서 리스트를 절반으로 나누기 때문
- 깊이 i의 노드들에서 이루어지는 총 작업량 : O(n)
    - 2i승개의 크기 n/2i승의 리스트들을 분할하고 합병하기 때문
    - 2i+1승번의 재귀호출 발생
- 따라서 merge-sort의 전체 실행 시간 : O(nlogn)
- 점화식으로도 해결 가능
    - T(n) = c ---> (n < 2)
    - T(n) = 2T(n/2) + O(n) ---> (n >= 2)
    - T(n) = O(nlogn) 결과!

### 응용문제 : 배열에 대한 합병 정렬
- 일반 리스트가 아닌 배열에 작동하는 merge-sort알고리즘의 버전을 작성하라
    - mergeSort(A) : n개의 원소로 구성된 배열 A를 합병 정렬
- 힌트 : 외부 배열을 "버퍼" 즉, 임시 저장 공간으로 사용



