# <strong>퀵 정렬</strong>

### 퀵 정렬 - 분할통치법에 기초한 정렬 알고리즘
- 분할 : 기준원소 p를(보통은 마지막 원소)를 택하여 L을 다음 세 부분으로 분할
    1. LT (p보다 작은 원소들)
    2. EQ (p와 같은 원소들)
    3. GT (p보다 큰 원소들)
- 재귀 : LT와 GT를 정렬
- 통치 : LT, EQ, GT를 결합

### 리스트 분할
- 입력 리스트를 다음과 같이 분할
    1. L로부터 각 원소 e를 차례로 삭제
    2. e를 기준원소 p와의 비교 결과에 따라 부리스트 LT, EQ, GT에 삽입
 - 삽입과 삭제를 리스트의 맨앞이나 맨뒤에서 수행하므로 O(1)시간 소요
 - 따라서, quick-sort의 분할단계는 O(n) 시간 소요

### 기준원소 선택
- 리스트 원소 가운데 기준원소(pivot) 선택
    1. 결정적이며 쉬운 방법
        - 맨 앞 원소
        - 맨 뒤 원소
        - 중간 원소
    2. 결정적이며 조금 복잡한 방법
        - 맨 앞, 중간, 맨 뒤 위치의 세 원소의 중앙값
        - 0/4, 1/4, 2/4, 3/4, 4/4 위치의 다섯 원소의 중앙값
        - 전체 원소의 중앙값
    3. 무작위한 방법
        - 무작위 방식으로 원소 선택
- 기준원소 선택의 영향
    1. 분할 결과
    2. 퀵 정렬 수행 성능

### 퀵 정렬 트리
- quick-sort의 실행을 이진트리로 도식화
    1. 이진트리의 각 노드는 quick-sort의 재귀호출을 표현하며 다음을 저장
        - 실행 이전의 무순 리스트 및 기준 원소
        - 실행 이후의 정렬 리스트
    2. 루트는 초기 호출을 의미
    3. 잎들은 크기 0또는 1의 부리스트에 대한 호출을 의미

### 최악실행시간
- quick-sort의 최악은 기준원소가 항상 유일한 최소이거나 최대 원소일 경우
- 이 경우 LT와 GT 가운데 하나는 크기가 n-1이며, 다른 쪽은 크기가 0
- 실행시간은 다음 합에 비례 : n + (n - 1) + . . . + 2 + 1
- 따라서 quick-sort의 최악실행시간 : O(n^)

### 기대실행시간
- 크기 s의 리스트에 대한 quick-sort의 재귀 호출을 고려하면
    1. 좋은 호출 : LT와 GT의 크기가 모두 (3/4)s 보다 작다
    2. 나쁜 호출 : LT와 GT의 가운데 하나의 크기가 (3/4)s 보다 크다
- 호출이 좋을 확률은 1/2 (예시 : 동전 던지기)
    1. 가능한 기준원소의 1/2은 좋은 호출을 부른다

### 무작위 퀵 정렬
- quick-sort의 결정적 버전에서는 기준원소로서 리스트로부터의 특정한 원소, 즉 마지막 원소를 선택하였다.
- 기준원소 선택을 위한 새로운 규칙 "입력 리스트의 무작위 원소를 선택하라"
- 확률적 상식 : k개의 헤드를 얻기 위한 동전던지기의 기대횟수는 2k다.

### 무작위 퀵 정렬의 기대실행시간
- 깊이 i의 노드에 대해 다음을 기대할 수 있다. 
    1. i/2개의 조상 : 좋은 호출
    2. 현재 호출을 위한 입력 리스트의 크기 : 최대 (3/4)의 i/2승 * n
- 따라서 
    1. 깊이 2log4/3n의 노드에 대해, 기대 입력 크기 : 1
    2. 퀵 정렬 트리의 기대 높이 : O(log n)
- 같은 깊이의 노드들에 대해 수행되는 작업량 : O(n)
- 따라서 quick-sort의 기대실행시간 : O(nlog n)

### 제자리 퀵 정렬
- quick-sort를 제자리에서 수행되도록 구현 가능
- 분할 단계에서, 입력 리스트의 원소들을 재배치하기 위해 대체 작업을 사용
    - LT : a보다 아래의, 기준원소보다 작은 원소들
    - EQ : a와 b사이의, 기준원소와 같은 원소들
    - GT : b보다 위의, 기준원소보다 큰 원소들