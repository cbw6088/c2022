## <strong>우선순위 큐 : 선형 / 힙</strong>
### <strong>우선순위 큐</strong>
- 일반적인 큐와는 다르게 데이터를 순서대로 추가 / 제거하는 것이 아니라 우선순위에 따라 데이터를 추가 / 제거하는 데이터 구조이다.

### <strong>선형 배열 or 연결리스트를 사용한 우선순위 큐</strong>
- 작동방식
    - 삽입 : 새로운 요소를 배열/연결리스트의 끝에 추가한다.
    - 삭제 : 최대(또는 최소) 우선순위의 요소를 찾아 제거한다. (이를 위해서는 전체 데이터를 순회)
- 장점
    - 구현이 간단하다.
    - 데이터가 작은 경우에는 충분히 빠르다.
- 단점
    - 크기가 큰 데이터 집합에 대해서는 비효율적이다.
    - 특히 최대(또는 최소) 값을 찾기 위해 전체 데이터를 순회해야 하는 것이 큰 단점이다.

### <strong>힙을 사용한 우선순위 큐</strong>
- 작동방식
    - 삽입 : 새로운 요소는 힙의 마지막 위치에 일단 삽입되고, 그 후 적절한 위치로 올라가게 된다.(up-heap)
    - 삭제 : 루트 요소(최대/최소)가 제거되고, 마지막 요소가 루트 위치로 옮겨진 후 적절한 위치로 내려간다. (down-heap)
- 장점
    - 삽입 및 삭제 연산이 로그 시간 복잡도로 효율적이다.
    - 동적으로 크기가 변경될 수 있는 데이터 집합에 효율적이다.
    - 최대값 또는 최소값 접근이 O(1)로 매우 빠르다.
- 단점
    - 힙의 구조를 유지하기 위한 추가적인 작업이 필요하다.
    - 힘의 내부 구조가 연속적인 메모리 공간을 사용하지 않기 때문에, 메모리 캐시의 이점을 적극적으로 활용하기 어렵다.

## <strong>힙과 힙정렬</strong>
### <strong>힙(Heap)</strong>
- 주로 배열을 통해 표현되는 완전 이진 트리의 일종으로 특별한 성질을 가진다. 그 성질에 따라 최대 힙과 최소 힙으로 나눌 수 있다.
- 최대 힙(Max Heap) : 각 노드의 값은 해당 노드 자식의 값보다 크거나 같아야 한다.
- 최소 힙(Min Heap) : 각 노드의 값은 해당 노드 자식의 값보다 작거나 같아야 한다.
- 힙은 트리 구조지만 주로 배열로 구현된다. 배열의 인덱스를 이용하여 부모 노드와 자식 노드 간의 관계를 쉽게 파악할 수 있다.
    - 부모노드 : i
    - 왼쪽 자식 노드 : 2 * i
    - 오른쪽 자식 노드 : 2 * i + 1

### <strong>힙의 주요 연산</strong>
- 삽입(Insertion) : 힙의 마지막 위치에 새로운 요소를 추가하고, 힙의 성질을 만족시키도록 요소의 위치를 조정한다.
- 삭제(Deletion) : 힙의 루트 요소를 제거하고, 마지막 요소를 루트로 옮긴 후 힙의 성질을 만족시키도록 요소의 위치를 조정한다.

### <strong>힙 정렬(Heap Sort)</strong>
- 힙 정렬은 힙의 성질을 활용하여 배열을 정렬하는 방법이다. 아래는 힙 정렬의 기본 원리를 설명한다.
- Build Heap : 주어진 배열로부터 최대 힙을 구축한다.
- Sort : 힙에서 가장 큰 요소(루트)를 꺼내어 배열의 마지막 위치에 저장하고, 힙의 크기를 1 줄인다. (크기가 1이 될 때 까지 반복)

### <strong>힙 정렬의 특징</strong>
- 시간 복잡도 : 힙 구축에 O(n)의 시간이 걸리고, n번의 삭제 연산 각각에 O(log n)의 시간이 걸려 전체 복잡도는 O(log n)이다.
- In - place 정렬(제자리) : 추가적인 메모리를 사용하지 않고 배열 내에서 정렬이 이루어진다.
- 불안정 정렬 : 동일한 키값을 가진 레코드의 상대적인 순서가 정렬 후에 보장되지 않는다.
- 장점
    - 공간 복잡도가 좋다. (제자리 정렬)
    - 시간 복잡도가 O(log n)으로 일정하다.
- 단점
    - 다른 O(nlog n)정렬 알고리즘(ex : 퀵정렬)에 비해 실제 성능이 느리다.
    - 불안정 정렬이다.

## <strong>비교 정렬</strong>
- 비교 정렬은 정렬 알고리즘의 한 카테고리로 입력 데이터 간의 상대적인 순서를 결정하기 위해 요소들을 직접 비교하는 방식을 기반으로 한다. 즉, 정렬 알고리즘이 두 데이터 요소를 비교하여 둘 중 어느 것이 먼저 와야 하는지 결정하는 방식을 사용한다.
- 기본 원리 : 비교 정렬의 주요 원리는 입력된 데이터의 상대적 순서를 알기 위해 각 요소를 다른 요소와 비교하는 것이다.
### <strong>비교 정렬의 주요 알고리즘</strong>
- 버블 정렬(Bubble Sort) : 인접한 요소를 반복적으로 비교하고 필요에 따라 교환하여 정렬한다. O(n^)
- 선택 정렬(Selection Sort) : 주어진 리스트에서 최소(또는 최대)값을 찾아 맨 앞(또는 뒤)으로 옮기는 과정을 반복한다. O(n^)
- 삽입 정렬(Insertion Sort) : 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 요소를 하나씩 정렬된 부분에 적절한 위치에 삽입한다. O(n^)
- 병합 정렬(Merge Sort) : 주어진 데이터를 반으로 나누고 각각을 정렬한 뒤, 이를 다시 합병하는 방식으로 정렬 O(nlog n)
- 퀵 정렬(Quick Sort) : 특정 요소(피벗)를 선택하고 이를 기준으로 데이터를 두 그룹으로 나눈다. 각 그룹을 재귀적으로 퀵 정렬 한다. 평균 O(nlog n), 최악 O(n^)
- 힙 정렬(Heap Sort) : 데이터를 힙 구조로 만든 뒤 최대(또는 최소)값을 꺼내어 정렬된 부분에 추가하는 방식을 사용한다. O(nlog n)

### <strong>비교 정렬의 한계</strong>
- 비교 정렬의 시간 복잡도 하한은 O(nlog n)이다. 즉, 비교를 사용하여 정렬하는 모든 알고리즘은 최선의 경우에도 O(nlog n)의 시간 복잡도 이상을 가진다. 이 이론적 한계는 "비교 정렬의 하한"으로 알려져 있으며, 이는 결정 트리 모델을 사용하여 증명될 수 있다.
- 장점
    - 일반적이며 어떤 유형의 데이터에도 적용 가능하다.
    - 구현이 상대적으로 간단하 경우가 많다.
- 단점
    - O(nlog n)의 시간 복잡도 하한으로 인해, 비교를 사용하지 않는 정렬 알고리즘에 비해 느릴 수 있다.

## <strong>탐색 트리(Search Trees)</strong>
- 탐색 트리는 데이터를 효과적으로 저장하고 검색할 수 있도록 설계된 트리 기반의 데이터 구조이다.

### <strong>이진 탐색 트리(Binary Search Tree, BST)</strong>
- 정의 : 이진 탐색 트리는 각 노드에 하나의 키(key)를 갖는 이진 트리로, 다음의 조건을 만족한다.
    - 왼쪽 서브트리의 모든 키는 루트의 키보다 작다.
    - 오른쪽 서브트리의 모든 키는 루트의 키보다 크다.
    - 왼쪽과 오른쪽 서브트리 또한 이진 탐색 트리이다.
- 연산
    - 성능 -> 탐색, 삽입, 삭제 : O(log n) ~ O(n)
    - 효율은 트리의 균형에 따라 달라진다. 균형이 잘 유지되면 log n에 가깝지만, 최악의 경우 O(n)에 가깝다.
- 장점
    - 구현이 간단하다.
    - 중위 순회를 통해 정렬된 순서를 얻을 수 있다.
- 단점
    - 트리가 균형을 유지하지 않을 경우 탐색 / 삽입 / 삭제의 성능이 O(n)에 가까워진다.

### <strong>AVL 트리</strong>
- 정의 : AVL 트리는 이진 탐색 트리의 확장으로 트리의 균형을 유지하기 위해 추가된 높이 균형 조건을 만족한다. AVL 트리에서 모든 노드의 왼쪽과 오른쪽 서브 트리의 높이 차이(균형 인수)는 최대 1이다.
- 성능 -> 탐색, 삽입, 삭제 : O(log n)
- 장점
    - 균형 조건으로 인해 탐색 성능이 항상 O(log n)을 보장한다.
    - BST의 모든 장점을 포함한다.
- 단점
    - 삽입과 삭제 시 재균형 작업이 필요하므로 구현이 복잡하다.

### <strong>스플레이 트리(Splay Tree)</strong>
- 정의 : 스플레이 트리는 이진 탐색 트리의 일종으로 삽입, 삭제, 탐색 연산 시 해당 키를 루트로 이동시키는 연산을 수행한다.
- 성능
    - 탐색, 삽입, 삭제 : 최악의 경우 O(n)이지만, 특정 패턴의 연속된 작업에 대해서는 더 빠른 실행 시간을 보인다.
- 장점
    - 재균형 작업 없이 동적으로 균형 상태를 유지한다.
    - 접근 패턴에 적응하여 자주 접근하는 요소에 대한 작업을 빠르게 수행한다.
    - 구현이 AVL트리나 레드 - 블랙 트리보다 간단하다.
- 단점
    - 최악의 경우 성능이 O(n)이다.
- 스플레이 트리의 독특성 : 스플레이 트리는 최근에 수행한 연산에 따라 동적으로 구조가 변경되는데, 이 특성으로 인해 "어떤 키에 대한 연속된 접근"이 발생할 때 그 키를 빠르게 처리할 수 있다. 예를 들어, 여러 번의 연속된 탐색 요청이 같은 키에 대해 발생하면, 스플레이 트리는 해당 키를 루트에 유지하게 되므로 해당 키에 대한 탐색이 상수 시간에 가능해진다. 기본적으로 각 트리는 상황과 필요에 따라 선택해야 한다. AVL 트리는 항상 유지되어야 하는 경우에 적합하고, 스플레이 트리는 접근 패턴이 예측되는 경우에 유용하다.

### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>
### <strong></strong>

