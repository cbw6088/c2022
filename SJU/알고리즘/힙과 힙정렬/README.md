# <strong>힙과 힙정렬</strong>

### 힙(heap) : 내부노드에 키를 저장하며 다음 두 가지 속성을 만족하는 <strong>이진트리</strong>
- 힙순서(heap-order) : 루트를 제외한 모든 내부노드 v에 대해, key(v) >= key(parent(v))
- 완전이진트리(complete binary tree) : 힙의 높이를 h라 하면 
    - i = 0, ... , h-1에 대해 깊이 i인 노드가 2에 i승개 존재
    - 깊이 h-1에서, 내부노드들은 외부노드들의 왼쪽에 존재
- 힙의 마지막 노드(last node) : 깊이 h-1의 가장 오른쪽 내부 노드

### 힙의 높이
- 정리 : n개의 키를 저장한 힙의 높이는 O(ing n)이다.
- 증명 : 완전이진트리의 성질을 이용
    - n개의 키를 저장한 힙의 높이를 h라 하자
    - 깊이 i = 0, ... , h-2에 2에 i승개의 키, 그리고 깊이 h-1에 적어도 한 개의 키가 존재하므로, n >= 1 + 2 + 4 + ... + 2에 h-2승 + 1
    - 따라서, n >= 2에 h-1승, 즉 h <= log n+1

### 힙과 우선순위 큐
- 힙을 사용하여 우선순위 큐 구현 가능
- 전제 : 적정이진트리로 구현
- 마지막 노드의 위치를 관리
- 그림 표기 : 내부노드 내에 간단히 키만 표시

### 힙에 삽입 (삽입식)
- 우선순위 큐 ADT의 메쏘드 insertltem은 힙에 키 k를 삽입하는 것에 할당
- 삽입 알고리즘의 세 단계
    1. 삽입 노드 z, 즉 새로운 마지막 노드를 찾는다.
    2. k를 z에 저장한 후 expandExternal(w)작업을 사용하여 z을 내부노드로 확장
    3. 힙순서 속성을 복구

### Up-heap
- 새로운 키 k가 삽입된 후, 힙순서 속성이 위배될 수 있다.
- 알고리즘 upheap은 삽입노드로부터 상향 경로를 따라가며 키 k를 교환함으로써 힙순서 속성을 복구
- upheap은 키 k가 루트에, 또는 부모의 키가 k보다 작거나 같은 노드에 도달하면 정지
- 힙의 높이는 O(log n)이므로 upheap은 O(log n)시간에 수행

### 힙으로부터 삭제
- 우선순위 큐 ADT의 메쏘드 removeMin은 힙으로부터 루트 키를 삭제하는 것에 해당
- 삭제 알고리즘의 세 단계
    1. 루트 키를 마지막 노드 w의 키로 대체
    2. reduceExternal(z)작업을 사용하여 w와 그의 자식들을 외부노드로 축소
    3. 힙순서 속성을 복구

### Down-hemp
- 루트 키를 마지막 노드의 키로 대체한 후, 힙순서 속성이 위배될 수 있다.
- 알고리즘 downheap은 루트로부터 하향 경로를 따라가며 키 k를 교환함으로써 힙순서 속성을 복구
- downheap은 키 k가 잎에, 또는 자식의 키가 k보다 크거나 같은 노드에 도달하면 정지
- 힙의 높이는 O(log n)이므로 downheap은 O(log n)시간에 수행

### 마지막 노드 갱신
- O(iog n)개의 노드를 순회함으로써 삽입 노드를 찾을 수 있다.
    - 현재 노드가 오른쪽 자식인 동안, 부모 노드로 이동
    - 현재 노드가 왼쪽 자식이면, 형제 노드로 이동
    - 현재 노드가 내부노드인 동안, 왼쪽 자식으로 이동
- 삭제 후 마지막 노드를 갱신하는 작업은 위와 반대 방향으로 수행

### 배열에 기초한 힙 구현
- n개의 키를 가진 힙을 크기 n의 배열을 사용하여 표현 가능
- 첨자 i에 존재하는 노드에 대해
    - 왼쪽 자식은 첨사 2i에 존재
    - 오른쪽 자식은 첨자 2i+1에 존재
    - 부모는 첨사 i/2에 존재
- 노드 사이의 링크는 명시적으로 저장할 필요가 없다.
- 외부노드들은 표현할 필요 없다.
- 첨자 0셀은 사용하지 않는다.
- 마지막 노드의 첨자 : 항상 n
    - insertltem 작업은 첨자 n+1위치에 삽입하는 것에 해당
    - removeMin 작업은 첨자 n위체에서 삭제하는 것에 해당

### 힙 정렬
- 힙을 사용하여 구현된 n항목 우선순위 큐를 고려하면
    - 공간 사용량은 O(n)
    - insertltem 메쏘드와 removeMin 메쏘드는 O(log n)시간에 수행
    - size, isEmpty, minKey, minElement 메쏘드는 O(1)시간에 수행
- 힙에 기초한 우선순위 큐를 사용함으로써, n개의 원소로 이루어진 리스트를 O(nlog n)시간에 정렬할 수 있다.
    - 선택 정렬이나 삽입 정렬과 같은 2차 정렬 알고리즘보다 훨씬 빠르다.
    - 이 알고리즘을 힙정렬 알고리즘이라고 부른다.

### 힙 정렬 개선
- Heap sort의 성능 향상을 위한 두 가지 개선점
    - 제자리 힙 정렬은 heap sort의 공간 사용을 줄인다.
    - 상향식 힙생성은 heap sort의 속도를 높인다.

### 제자리 힙 정렬
- 이 방식은 정렬되어야 할 리스트가 배열로 주어진 경우에만 적용
- 힙을 저장하는데 리스트 L의 일부를 사용함으로써 외부 힙 사용을 피한다.
- 지금까지 사용했던 최소힙 대신, 최대 원소가 맨 위에 오게 되는 최대힙을 사용

### 제자리 힙 정렬(conti)
- 알고리즘 수행의 어떤 시점에서든
    - L의 첨자 1부터 i까지의 왼쪽 부분은 힙의 원소들을 저장하는데 사용
    - 그리고 첨자 i+1부터 n까지의 오른쪽 부분은 리스트의 원소들을 저장하는데 사용
- 그러므로 L의 (첨자 1, ... , i에 있는) 첫 i개의 원소들은 힙의 배열 표현
- 즉, 첨자 k의 원소는 첨자 2k 및 2k+1의 자식들보다 크거나 같다

### 제자리 힙 정렬 (conti)
- 1기
    - 비어있는 힙으로부터 출발하여 힙과 리스트의 경계를 왼쪽에서 오른쪽으로 한 번에 한 칸씩 이동
    - 단계 i (i=1, ... ,n)에서 첨자 i에 있는 원소를 힙에 추가함으로써 힙을 확장
- 2기
    - 비어있는 리스트로부터 출발하여 힙과 리스트의 경계를 오른쪽에서 왼쪽으로 한 번에 한 칸씩 이동
    - 단계 i (i=n, ... ,2)에서 힙의 최대 원소를 삭제하여 리스트의 첨자 i에 저장함으로써 리스트를 확장

### 제자리 힙 정렬 예
- 1기와 2기의 각 단계에서, 배열 가운데 힙에 쓰인 부분을 파란색 원소로 표시
- 아래 점선 내에 보인 이진트리 관점의 힙은 가상적일 뿐, 제자리 알고리즘에 의해 실제 생성되지 않음에 유의
- 1기 작업 시작

### 상향식 힙생성
- heap-sort의 1기에서 n회의 연속적인 insertltem 작업을 사용하여 O(nlog n)시간에 힙을 생성했었다
- 대안으로, 만약 힙에 저장되어야 할 모든 키들이 미리 주어진다면, O(n)시간에 수행하는 상향식 생성 방식이 있다.

### convertToCompleteBinaryTree
- 리스트 L을 완전이진트리 T로 전환
- 배열 L로부터 순차힙 생성할 경우
    - 입력 배열 L을 첫 번째 원소를 루트로 하는 완전이진트리로 볼 수 있으므로 전환 작업 생략 가능
- 연결리스트 L로부터 연결힙 생성할 경우
    - 전환 작업 수행에 O(n)시간 소요

### 상향식 힙생성
- log n 단계만을 사용하여 주어진 n개의 키를 저장하는 힙 생성 가능
- 단계 i에서, 각각 2의 i승-1개의 키를 가진 두 개의 힙을 2의 i+1승개의 키를 가진 힙으로 합병

### 두 개의 힙을 합병
- 두 개의 힙과 키 k가 주어졌을 때
- k를 저장한 노드를 루트로, 두 개의 힙을 부트리로 하는 새 힙을 생성
- 힙순서 속성을 복구하기 위해 downheap을 수향

### "상향식"이라고 불리는 이유
- 이 버전은 각 재귀호출이 힙인 부트리를 반환하는 방식 때문에 상향식이라 불린다
- T의 힙화는 외부노드에서 시작하여, 각 재귀호출이 반환함에 따라 트리 위쪽으로 진행
- 이 때문에 종종 힙화한다고 말하기도 한다

### 비재귀적 상향식 힙생성
- 상향식 힙생성의 비재귀 버전
- 정렬되어야 할 리스트가 배열로 주어진 경우에만 적용
- 이 방식은 힙생성 절차가 "내부노드를 왼쪽 자식으로 가지는 가장 깊은 내부노드 가운데 가장 오른쪽 노드"에서 시작하여 루트로 향하는 후진방향으로 반복 수행
- 시작 노드 : 첨자 n/2인 노드
- 예 : n = 6

### 분석
- downheap의 최악의 경우 시간을 대리경로를 사용하여 시각화하기
    - 이 대리경로는 먼저 오른쪽 자식노드로 이동한 후 힙의 바닥까지 반복적으로 왼쪽 자식노드를 따라 이동
    - 이 경로는 대리경로일 뿐 실제 downheap경로와는 다를 수 있다
- 각 노드는 최대 두 개의 대리경로에 의해 순회되므로, 대리경로들의 전체 노드 수는 O(n)
- 따라서, 상향식 힙생성은 O(n)시간에 수행
- 하지만, heap-sort 2기의 최악실행시간은 오메가(nlog n)
- 상향식 힙생성은 n회의 연속적인 삽입보다 빠르므로 heap-sort 1기의 속도를 향상시킨다

