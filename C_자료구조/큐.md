# <strong>Queue</strong>
- 큐 역시 스택과 마찬가지로 일종의 리스트
- 단, 데이터의 삽입은 한쪽 끝에서, 삭제는 반대쪽 끝에서만 일어남
- 삽입이 일어나는 쪽을 rear, 삭제가 일어나는 쪽을 front라고 부름
- FIFO (First - In - First - Out)
- ex) 프린터 큐 등 . . .
- insert, enqueue, offer, push : 큐의 rear에 새로운 원소를 삽입하는 연산
- remove, dequeue, poll, pop : 큐의 front에 있는 원소를 큐로부터 삭제하고 반환하는 연산
- peek, element, front : 큐의 front에 있는 원소를 제거하지 않고 반환하는 연산
- is_empty : 큐가 비어있는지 검사

### <strong>큐와 스택의 차이</strong>
- 스택은 마지막에 들어온 데이터 순으로 반환 (동전 쌓기)
- 큐는 먼저 들어온 데이터 순으로 반환 (영화표 끊기)

### <strong>큐의 응용</strong>
- CPU 스케쥴링 : multitasking 환경에서 프로세스들은 큐에서 CPU가 할당되기를 기다림
- 데이터 버퍼 : 네트워크를 통해 전송되는 패킷(packet)들은 도착한 순서대로 버퍼에 저장되어 처리되기를 기다림
- 그 외에도 자원을 공유하는 대부분의 경우에 큐가 사용됨

### <strong>연결리스트로 구현</strong>
- 큐의 rear에서는 삽입, front에서는 삭제가 일어남.
- 따라서, 연결리스트의 앞 쪽을 front 뒷 쪽을 rear로 하는 것이 유리
- 삽입을 하기 위해서는 마지막 노드의 주소를 항상 기억해야 함

```c++
/*헤더파일*/
#ifndef QUEUEADT_H
#define QUEUEADT_H

#include <stdbool.h>
typedef int Item;

typedef struct queue_type *Queue;

Queue create();
void destroy(Queue q);
void make_empty(Queue q);
bool is_empty(Queue q);
void enqueue(Queue q, Item i);
Item dequeue(Queue q);
Item peek(Queue q);
int get_size(Queue q);

#endif
```
```c++
#include <stdio.h>
#include <stdlib.h>
#include "queueADT.h"

struct node{
    Item data;
    struct node *next;
};

struct queue_type{
    struct node *front;
    struct node *rear;
    int size;
};

void terminate(const char *message){
    printf("%s\n", message);
    exit(EXIT_FAILURE);
}

int get_size(Queue q){
    return q->size;
}

Queue creat(){
    Queue q = (Queue)malloc(sizeof(struct queue_type));
        // struct queue_type == *Queue
    if(q == NULL)
        terminate("Error in create : queue could not be created.");
    q->front = NULL;
    q->rear = NULL;
    q->size = 0;
    return q;
}

void destroy(Queue q){
    make_empty(q);
    free(q);
}

void make_empty(Queue q){
    while(!is_empty)
        dequeue(q);
    q->size = 0;
}

bool is_empty(Queue q){
    return q->front == NULL;
}

void emqueue(Queue q, Item i){
    struct node *new_node = (Queue)malloc(sizeof(struct node));
    if(new_node == NULL)
        terminate("Error in push : queue is full.");
    new_node->data = i;
    new_node->next = NULL;
    if(q->front == NULL){
        q->front = new_node;
        q->rear = new_node;
    }
    else{
        q->rear->next = new_node;
        q->rear = new_node;
    }
    q->size++;
}

Item dequeue(Queue q){
    struct node *old_front;
    Item i;
    if(is_empty(q))
        terminate("Error in dequeue : queue is empty.");
    old_front = q->front;
    i = old_front->data;
    q->front = old_front->next;
    if(q->front == NULL)
        q->rear = NULL;
    free(old_front);
    q->size--;
    return i;
}

Item peek(Queue q){
    if(is_empty(q))
        terminate("Error in peek : queue is empty");
    return q->front->data;
}

```

### <strong>배열로 구현</strong>
- front와 rear의 위치를 지정
- 반드시 front가 앞 rear이 뒤인건 아님
- front부터 지워나가기 시작
- 채울땐 다시 rear부터 채우기
<img width="933" alt="image" src="https://user-images.githubusercontent.com/99342700/210736478-57482832-e853-44a7-8b28-41c2c2ddf7ff.png">

```c++
/*헤더파일은 연결리스트와 동일*/
#include <stdio.h>
#include <stdlib.h>
#include "queueADT.h"

#define INIT_CAPACITY 100
struct queue_type{
    Item *contents;
    int front;
    int rear;
    int size; // 저장된 데이터의 개수
    int capacity; // 배열 contents의 크기
};

void terminate(const char *mesage){
    printf("%s\n", message);
    exit(1);
}
int get_size(Queue q){
    return q->size;
}

Queue create(){
    Queue q = (Queue)malloc(sizeof(struct queue_type));
    if(q == NULL)
        terminate("Error in create : queue could not be created.");
    q->front = 0;
    q->rear = -1;
    q->size = 0;
    q->capacity = INIT_CPAPACITY;
}

void destroy(Queue q){
    free(q->contents);
    free(q);
}

void make_empty(Queue q){
    q->front = 0;
    q->rear - -1;
    q->size = 0;
}

bool is_empty(Queue q){
    return q->size == 0;
}

bool is_full(Queue q){
    return q->size == q->capacity;
}

void enqueue(Queue q, Item i){
    if(is_full(q))
        reallocate(q); // 배열의 크기 키우기
    q->rear = (q->rear + 1) % q->capacity; // 1 증가시키면서 배열보다 큰 경우 맨 앞으로
    q->contents[q->rear] = i;
    q->size++;
}

Item dequeue(Queue q){
    if(is_empty(q))
        terminate = ("Error in dequeue : queue is empty.");
    Item result = q->contents[q->front];
    q->front = (q->front + 1) % q->capacity; // 1 증가시키면서 배열보다 큰 경우 맨 앞으로
    q->size--;
    return result;
}

Item peek(Queue q){
    if(is_empty(q))
        terminate("Error in peek : queue is empty.");
    return q->contents[q->front];
}

void reallocate(Queue q){
    Item *tmp = (Item*)malloc(2 * q->capacity * sizeof(Item)); // 기존의 배열보다 2배 큰 배열
    if(tmp == NULL)
        terminate("Error in create : queue could not be expanded.");
    int j = q->front;
    for(int i = 0; i < q->size; i++){ // 기존의 배열 반복
        tmp[i] = q->contents[j];
        j = (j + 1) % q->capacity;
    }
    free(q->contents); // 기존 배열 제거
    q->front = 0;
    q->rear = q->size - 1;
    q->contents = tmp; // 새로운 배열로 연결
    q->capacity *= 2;
}
```