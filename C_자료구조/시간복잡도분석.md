# 연결리스트 이후에 다시 보기 (정리 하다가 맘) #
# <strong>시간 복잡도 분석</strong>

### <strong>push and pop : 배열로 구현한 경우</strong>
```c++
void push(Stack s, Item i){
    if(is_full(s))
        reallocate(s);
    /* 스택에 저장된 데이터의 개수를 n이라고 하면 */
    /* reallocate함수의 시간 복잡도는 O(n) */
    s->top++;
    s->contents[s->top] = i;
    /* reallocate함수를 제외한 나머지 부분의 시간 복잡도는 O(1) */
}

Item pop(Stack s){
    if(is_empty(s))
        terminate("Error in pop : stack is empty.\n");
    s->top--;
    return s->contents[s->top + 1];
    /* pop()함수의 시간 복잡도는 O(1) */
}
```

### <strong>push and pop : 연결리스트로 구현한 경우</strong>
- 스텍을 연결리스트로 구현한 경우 push와 pop 모두 O(1)이다.
```c++
void push(Stack s, Item i){
    struct node *new_node = malloc(sizeof(struct node));
    if (new_node == NULL)
        terminate("Error in push : stack is full.\n");
    new_node->data = i;
    new_node->next = s->top;
    s->top = new_node;
}

Item pop(Stack s){
    struct node *old_top;
    Item i;
    if(is_empty(s))
        terminate("Error in pop : stack is empty.\n");
    old_top = s->top;
    i = old_top->data;
    s->top = old_top->next;
    free(old_top);
    return i;
}
```

### <strong>enqueue and dequeue</strong>
- 배열로 구현한 경우 reallocate를 제외하면 모두 O(1)
- 연결리스트로 구현한 경우 모두 O(1)

### <strong>정렬된 리스트에 삽입하기 : 배열의 경우</strong>
- 최악의 경우 시간 복잡도는 O(n)
```c++
void insert_to_ordered_array(int n, int data[], int item){
    int i = n - 1;
    for(; i >= 0 && data[i] > item; i--)
        data[i + 1] = data[i];
    data[i + 1] = item;
}
```

### <strong>정렬된 리스트에 삽입하기 : 연결리스트의 경우</strong>
- 최악의 경우 시간복잡도는 O(n)
```c++
Node *insert_to_ordered_linked_list(Node *head, int item){
    Node *new_node = (Node*)malloc(sizeof(Node));
    new_node->data = item;
    new_node->next = NULL;
    Node *p = head, *q = NULL;
    while(p != NULL && p->data < item){
        q = p;
        p = p->next;
    }
    if(q == NULL){
        new_node->next = head;
        head = new_node;
    }
    else{
        new_node->next = p;
        q->next = new_node;
    }
    return head;
    /* 연결리스트의 첫 번째 노드의 주소를 저장하는 변수가 전역변수가 아니라고 가정 */
    /* 첫 번째 노드의 주소를 변경할 가능성이 있는 함수들은 항상 첫 번째 노드의 주로를 반환하도록 구현하는 것이 일반적 */
}
```