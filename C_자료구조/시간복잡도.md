# <strong>알고리즘의 분석</strong>
- 알고리즘의 자원(resource) 사용량을 분석
- 자원이란 실행 시간, 메모리, 저장 장치, 통신 등
    - 시간 : 속도
    - 메모리 : 공간
    - 저장 장치 : 특정 저장 장치의 용량 (하드디스크 등등)
    - 통신 : 통신 기능의 소프트웨어인 경우
- 여기서는 <strong>실행시간의 분석</strong>에 대해서 다룸

### <strong>시간 복잡도</strong>
- 실행 시간은 실행 환경에 따라 달라짐
    - 하드웨어, 운영체제, 언어, 컴파일러 등
- 실행 시간을 측정하는 대신 <strong>연산의 실행 횟수</strong>를 카운트
    - 항상 이런 것은 아니지만 이 방법이 일반적이고, 어떤 상황에서도 가능
- 연산의 실행 횟수는 입력 데이터의 크기에 관한 함수로 표현
- 데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐
    - <strong>최악의 경우</storng> 시간 복잡도 : 가장 대표적인 경우
    - <strong>평균</strong> 시간 복잡도 : 측정이 어려워서 잘 고려 안함

### <strong>점근적 표기법을 사용</strong>
- 데이터의 개수 n -> oo(무한) 일 때, 수행 시간이 증가하는 growth rate로 시간 복잡도를 표현하는 기법
- O-표기 등을 사용

### <strong>유일한 분석법도 아니고 가낭 좋은 분석법도 아님</strong>
- 다만 (상대적으로) 가장 간단하며
- 알고리즘의 실행환경에 비의존적임
- 그래서 가장 광범위하게 사용됨

### <strong>점근적 분석의 예 : 상수 시간 복잡도</strong>
- 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 중 n/2번째 데이터를 반환
- n에 관계 없이 상수 시간이 소요됨
- 이 경우 알고리즘의 시간 복잡도는 O(1)
```c++
int sample(int data[], int n)
{
    int k = n / 2;
    return data[k];
}
```

### <strong>점근적 분석의 예 : 선형 시간 복잡도</strong>
- 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 합을 구하여 반환
- 선형 (1차) 시간 복잡도를 가진다고 말하고 시간 복잡도는 O(n)
```c++
int  sum(int data[], int n)
{
    int sum = 0;
    for(int i = 0; i < n; i++)
        sum += data[i];
    /* 실행 횟수는 항상 n번 */
    return sum;
}
```

### <strong>선형 시간 복잡도 : 순차 탐색</strong>
- 배열 data에 정수 target이 있는지 검색
- 평균 / 최선 / 최악의 경우 모두 존재
```c++
int search(int n, int data[], int target)
{
    for(int i = 0; i < n; i++){
        /* 최악의 경우 n */
        if(data[i] == target)
            return i;
    }
    return -1;
}
```
- 최악의 경우 배열에 저장된 모든 원소 쌍을 비교 하므로 비교 연산의 횟수는 n(n-1)/2
- 최악의 경우 시간 복잡도는 O(n^)
```c++
bool is_distinct(int n, int x[])
{
    for(int i = 0; i < n - 1; i++){
        for(int j = i + 1; j < n; j++){
            /* 최악의 경우 n(n - 1) / 2 */
            if(x[i] == x[j])
                return false;
        }
    }
    return true;
}
```

### <strong>점근적 표기법</strong>
- 알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법
- 최고차항의 수치만으로 표시
- 따라서, 가장 자주 실행되는 연산 혹은 문장의 실행 횟수를 고려하는 것으로 충분
<img width="305" alt="image" src="https://user-images.githubusercontent.com/99342700/216975390-012b7afd-0542-4675-ad85-4b292215304c.png">
<img width="494" alt="image" src="https://user-images.githubusercontent.com/99342700/216975759-2e1e99d9-6269-45d0-af7c-4ceb64e512a9.png">

### <strong>Big - O란?</strong>
- big-O는 알고리즘의 효율성을 나타내는 지표이다.
- big-O를 이용하여 알고리즘의 성능을 판단한다.
- big-O표기법은 보통 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는데 주로 사용
    - 시간 복잡도는 알고리즘의 시간 효율성을 의미
    - 시간 복잡도란 시간 개념으로 알고리즘의 수행 시간패턴이 얼마인지 나타냄
    - 시간이 늘어나는 패턴을 추상화로 표기한 것이 함수의 시간 소요를 일반화 하는 것

### <strong>Big - O 표기법</strong>
- big-O표기법은 데이터 입력값(n)의 크기에 따라 영향을 받음
- 그렇기 때문에 영향력이 큰 항 이외에 영향력이 없는 항들은 무시
- 최악의 상황을 고려해서 표기하며 입력값(n)의 표기는 제한이 없음
- O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!) < O(n^n)
- f(n) = 3n + n^ + 5 라면 영향령 있는 값이 n^이기 때문에 O(n^)
- O(2n) -> O(n) 상수항은 무시하기 때문에 O(n)으로 표현

### <strong>O(1) vs O(n)</strong>
- O(1)
    - 일정한 패턴
    - 입력값(n)의 크기와 상관 없이 항상 일정한 시간 패턴을 보이는 것을 O(1)이라고 표기
    - 예를 들면, 시간과 상관 없이 일정한 패턴을 보인다면 O(1)
- O(n)
    - 일정하게 증가하는 패턴
    - 입력값(n)의 크기에 따라 시간 패턴이 일정하게 늘어나는 것을 O(n)이라고 표기
    - 예를 들면, 데이터 구조 길이가 길수록 시간이 오래 걸린다면 O(n)
<img width="437" alt="image" src="https://user-images.githubusercontent.com/99342700/217196652-7929706a-7daf-4115-8cfa-4e4bc6c5910e.png">

### <strong>O(log n) vs O(n^)</strong>
- O(log n)
    - 증가하는 속도가 줄어들면서 증가하는 패턴을 한다.
    - 이진 트리 탐색으로 예를 들 수 있다.
    - 트리와 같은 구조로 자식이 2개 이하로만 존재하고 일정한 규칙으로 뻗어나가기 떄문에 순서가 있는 데이터 구조로 정리
    - 첫 시행 후 반이 바려지고 또 탐색하고 반이 버려지는 것을 반복한다면 시간 패턴은 속도가 점점 줄어들면서 증가하는 패턴
- O(n^)
    - 증가하는 속도가 점점 급격히 증가하는 패턴
    - 버블정렬을 예로 들 수 있음
    - 2중 for문을 사용하면서 정렬이 되어있지 않은 요소들을 하나하나 탐색할 때 O(n^)

<img width="474" alt="image" src="https://user-images.githubusercontent.com/99342700/217197892-12af1834-cc0d-449f-a327-7e6f46aa8553.png">